{"version":3,"file":"core-c492f101.js","mappings":"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","sources":["webpack://App/./resources/js/app/core/View.js"],"sourcesContent":["import { SEOTagConfig } from './SEOConfig.js';\nimport { ViewTemplates } from './ViewTemplate.js';\nimport { hasData, uniqId } from '../helpers/utils.js';\nimport { ViewEngine } from './ViewEngine.js';\nimport { ViewState } from './ViewState.js';\nimport { ATTR } from './ViewConfig.js';\nimport logger from './services/LoggerService.js';\nimport { OneMarkup } from './OneMarkup.js';\nimport { StorageService } from './services/StorageService.js';\nimport OneDOM from './OneDOM.js';\n\n\nclass SSRViewData {\n    constructor(viewData) {\n        const { instances, indexMap } = this.parseViewData(viewData);\n        this.instances = instances;\n        this.indexMap = indexMap;\n        this.index = 0;\n        this.maxIndex = indexMap.length - 1;\n    }\n    parseViewData(viewData) {\n        let instances = viewData.instances || {};\n        const instancesMap = new Map();\n        const keys = Object.keys(instances);\n        keys.forEach(key => {\n            instancesMap.set(key, instances[key]);\n        });\n        const indexMap = keys;\n        return {\n            instances: instancesMap,\n            indexMap: indexMap,\n        };\n    }\n    get(index = null) {\n        if (index === null) {\n            index = this.index;\n        }\n        this.index = index;\n        return this.instances.get(this.indexMap[index]) ?? null;\n    }\n    next() {\n        this.index++;\n        return this.get(this.index);\n    }\n    prev() {\n        this.index--;\n        return this.get(this.index);\n    }\n    getById(id) {\n        return this.instances.get(id) ?? null;\n    }\n    scan() {\n        let index = this.index;\n        this.index++;\n        let instance = this.get(index);\n        if (!instance) {\n            this.index--;\n            return null;\n        }\n        return instance;\n    }\n}\n\nclass SSRViewDataCollection {\n    constructor(views) {\n        /**\n         * @type {Object<string, SSRViewData>}\n         */\n        this.views = new Map();\n        this.setViews(views);\n    }\n    setViews(views) {\n        if (typeof views !== 'object' || !views || Object.keys(views).length === 0) {\n            return;\n        }\n        Object.keys(views).forEach(name => {\n            this.views.set(name, new SSRViewData(views[name]));\n        });\n    }\n    get(name) {\n        return this.views.get(name) ?? null;\n    }\n    scan(name) {\n        return this.get(name)?.scan() ?? null;\n    }\n    getInstance(name, id) {\n        return this.get(name)?.getById(id) ?? null;\n    }\n}\n\nexport class View {\n    constructor(App = null) {\n        /**\n         * @type {Application}\n         */\n        this.App = App;\n\n        this.markupService = OneMarkup;\n        /**\n         * @type {StorageService}\n         */\n        this.storageService = StorageService.getInstance('onejs_view_data');\n        /**\n         * @type {HTMLElement}\n         */\n        this.container = null;\n        /**\n         * @type {Object<string, function>}\n         */\n        this.stateChangeListeners = {};\n        /**\n         * @type {ViewEngine}\n         */\n        this.currentMasterView = null;\n        /**\n         * @type {ViewEngine}\n         */\n        this.Engine = ViewEngine;\n        /**\n         * @type {ViewState}\n         */\n        this.State = ViewState;\n        /**\n         * @type {Object<string, ViewEngine>}\n         */\n        this.templates = ViewTemplates;\n        /**\n         * @type {Object<string, string>}\n         */\n        this._sections = {};\n        /**\n         * @type {Array<string>}\n         */\n        this._changedSections = [];\n        /**\n         * @type {Object<string, Array<string>>}\n         */\n        this._stacks = {};\n\n        /**\n         * @type {boolean}\n         */\n        this.scanMode = false;\n        /**\n         * @type {Object<string, boolean>}\n         */\n        this._once = {};\n        /**\n         * @type {HTMLElement}\n         */\n        this.vitualContainer = document.createElement('div');\n        this.vitualContainer.setAttribute('id', 'data-vitual-container');\n        this.vitualContainer.style.display = 'none';\n        /**\n         * @type {Array<ViewEngine>}\n         */\n        this.VIEW_MOUNTED_QUEUE = [];\n        /**\n         * @type {ViewEngine}\n         */\n        this.CURRENT_SUPER_VIEW = null;\n\n        this.CURRENT_SUPER_VIEW_PATH = null;\n        /**\n         * @type {boolean}\n         */\n        this.CURRENT_SUPER_VIEW_MOUNTED = false;\n        /**\n         * @type {ViewEngine}\n         */\n        this.CURRENT_VIEW = null;\n\n        this.CURRENT_VIEW_PATH = null;\n        /**\n         * @type {boolean}\n         */\n        this.CURRENT_VIEW_MOUNTED = false;\n\n        /**\n         * @type {Array<ViewEngine>}\n         */\n        this.SUPER_VIEW_STACK = [];\n        /**\n         * @type {Array<ViewEngine>}\n         */\n        this.ALL_VIEW_STACK = [];\n        /**\n         * @type {ViewEngine}\n         */\n        this.PAGE_VIEW = null;\n        /**\n         * @type {number}\n         */\n        this.renderTimes = -1;\n\n        /**\n         * @type {Object<string, ViewEngine>}\n         */\n        this.cachedViews = {};\n        /**\n         * @type {Object<string, any>}\n         */\n        this.serverRenderData = {};\n        /**\n         * @type {Map<string, ViewEngine>}\n         */\n        this.viewMap = new Map();\n\n        /**\n         * @type {Map<string, Object<string, any>>}\n         */\n        this.cachedPageData = new Map();\n\n        // document.body.appendChild(this.vitualContainer);\n        /**\n         * @type {Object<string, any>}\n         */\n        this.wrapperConfig = {\n\n        };\n\n        this.listeners = {};\n\n        this.ssrData = {};\n        this.ssrViewManager = new SSRViewDataCollection();\n\n        /**\n         * @type {Map<string, ViewEngine>}\n         */\n        this.cachedPageView = new Map();\n\n        this.cachedTimes = 600; // máº·c Ä‘á»‹nh cache 10 phÃºt\n\n\n        /**\n         * @type {Object<string, any>}\n         */\n        this.SEO = {\n            tags: SEOTagConfig,\n            updateItem: function (key, value) {\n                const items = this.tags[key];\n                if (!items || items.length == 0) return false;\n                items.forEach(item => {\n                    let element = document.querySelector(item.selector);\n                    if (!element) {\n                        element = document.createElement(item.tag);\n                        if (item.attrs) {\n                            Object.entries(item.attrs).forEach(([key, value]) => {\n                                element.setAttribute(key, value);\n                            });\n                        }\n                        document.head.appendChild(element);\n                    };\n\n                    if (item.attribute) {\n                        if (item.attribute == \"@content\") {\n                            element.textContent = value;\n                        } else {\n                            element.setAttribute(item.attribute, value);\n                        }\n                    }\n                });\n                return true;\n            }\n        };\n\n\n\n\n\n    }\n\n    setApp(app) {\n        this.App = app;\n    }\n    setContainer(container) {\n        this.container = container;\n    }\n\n    /**\n     * Initialize SPA\n     */\n    init(data = {}) {\n        // console.log('App.View initialized', data);\n\n        // Clear sections and stacks on page load\n        this._sections = {};\n        this._stacks = {};\n        this._once = {};\n        this._changedSections = [];\n\n        // Initialize views if not already done\n        if (!this.templates) {\n            this.templates = ViewTemplates;\n        }\n\n        // Initialize current scope\n        this._currentScope = 'web';\n\n        this.ssrData = data?.ssrData || {};\n        this.ssrViewManager.setViews(this.ssrData);\n    }\n\n    /**\n     * Get view by name\n     * @param {string} name - View name\n     * @returns {ViewEngine|null} View object or null if not found\n     */\n    getView(name) {\n        return this.templates[name] || null;\n    }\n\n\n    /**\n     * Load and render view with master view handling\n     * @param {string} name - View name\n     * @param {Object} data - Data to pass to view\n     * @param {string} urlPath - URL path for the view\n     * @returns {Object<html: string, error: string, superView: ViewEngine, isSuperView: boolean, needInsert: boolean, ultraView: ViewEngine>} Final rendered HTML string\n     */\n    loadView(name, data = {}, urlPath = '') {\n        // console.log('ðŸ” App.View.loadView called with:', name, data);\n        if (this.templates[name]) {\n            this.clearOldRendering();\n        }\n        this.renderTimes++;\n        let message = null;\n        this.CURRENT_SUPER_VIEW_MOUNTED = false;\n\n        try {\n            let hasCache = false;\n            if (this.cachedTimes > 0) {\n                let cacheKey = name.replace('.', '_') + '_' + urlPath?.replace(/\\//g, '_');\n                const cachedData = this.storageService.get(cacheKey);\n                if (cachedData) {\n                    data = { ...data, ...cachedData };\n                    hasCache = true;\n                }\n            }\n            // Get view from templates\n            let view = this.view(name, hasCache ? { ...data } : null);\n            // console.log('âœ… View loaded:', view);\n            if (!view) {\n                message = `App.View.loadView: View '${name}' not found`;\n                return {\n                    error: `App.View.loadView: View '${name}' not found`,\n                    html: null,\n                    superView: null,\n                    isSuperView: false,\n                    needInsert: false,\n                };\n            }\n            if (urlPath) {\n                view.urlPath = urlPath;\n            }\n            if (this.cachedTimes > 0) {\n                if (this.PAGE_VIEW instanceof ViewEngine) {\n                    const oldCacheData = this.PAGE_VIEW.data;\n                    let cacheKey = this.PAGE_VIEW.path.replace('.', '_') + '_' + this.PAGE_VIEW.urlPath?.replace(/\\//g, '_');\n                    this.storageService.set(cacheKey, oldCacheData, 3600); // cache trong 1 giá»\n                }\n            }\n\n            // Store view in array for tracking\n\n            let superView = null;\n            let superViewPath = null;\n            let result;\n            let currentViewPath = view.path;\n            let currentView = view;\n            let ultraView = view;\n            let renderIndex = 0;\n            // vÃ²ng láº·p Ä‘á»ƒ render view cho Ä‘áº¿n khi khÃ´ng cÃ³ super view hoáº·c khÃ´ng cÃ³ super view thÃ¬ render view\n            do {\n                try {\n                    // console.log('ðŸ” App.View.loadView in do while view:' + view.path);\n                    // kiá»ƒm tra view cÃ³ super view khÃ´ng\n                    if (view.hasSuperView) {\n                        this.ALL_VIEW_STACK.unshift(view);\n                        // console.log('ðŸ” App.View.loadView has super view:', view.superViewPath);\n                        superViewPath = view.superViewPath;\n                        result = this.renderView(view);\n                        view = result;\n                        view.setIsSuperView(true);\n                        if (view && typeof view === 'object') {\n                            superView = view;\n                            ultraView = view;\n                        }\n                        // console.log('ðŸ” App.View.loadView super view:', view);\n                    }\n                    // kiá»ƒm tra view cÃ³ pháº£i lÃ  super view khÃ´ng\n                    else if (view.isSuperView) {\n                        if (superViewPath !== view.path) {\n                            this.SUPER_VIEW_STACK.unshift(view);\n                            superViewPath = view.path;\n                        }\n                        // superViewPath = view.path;\n                        superView = view;\n                        // console.log('ðŸ” App.View.loadView is super view:', view.path);\n                        if (view.hasSuperView) {\n                            result = this.renderView(view, renderIndex > 0 ? view.data : null);\n                            view = result;\n                            view.setIsSuperView(true);\n                            if (view && typeof view === 'object') {\n                                superView = view;\n                                superViewPath = view.path;\n                                ultraView = view;\n                            }\n                        } else {\n                            result = '';// náº¿u lÃ  super view thÃ¬ khÃ´ng cáº§n thÃªm vÃ o queue vÃ  khÃ´ng render. Ä‘á»ƒ bÆ°á»›c sau xá»­ lÃ½\n                        }\n                    }\n                    // náº¿u khÃ´ng cÃ³ super view vÃ  khÃ´ng pháº£i lÃ  super view thÃ¬ render view\n                    else {\n\n                        this.ALL_VIEW_STACK.unshift(view);\n                        // this.PAGE_VIEW = view;\n                        // console.log('ðŸ” App.View.loadView normal view:', view.path);\n                        result = this.renderView(view, renderIndex > 0 ? view.data : null);\n                        ultraView = view;\n                    }\n                } catch (error) {\n                    message = `App.View.loadView: Error rendering view '${name}':` + error.message;\n                    console.error('ðŸ” App.View.loadView error:', error);\n                    return '';\n                }\n                renderIndex++;\n            } while (result && typeof result === 'object' && result instanceof ViewEngine)\n            // Update #spa-root with the final string\n            // console.log(\"view after check\", { currentViewPath, superViewPath })\n            try {\n                let html = result;\n                // diá»ƒu kiá»…n cÃ³ cáº§n insert content vÃ o html khÃ´ng\n                const needInsert = !(superViewPath && superViewPath === this.CURRENT_SUPER_VIEW_PATH);\n                if (superViewPath) {\n                    // kiá»ƒm tra view cÃ³ pháº£i lÃ  super view khÃ´ng\n                    if (!needInsert) { // náº¿u khÃ´ng cáº§n insert content vÃ o html thÃ¬ set trang thÃ¡i super view mounted = true\n                        // console.log('ðŸ” App.View.loadView need insert super view:', superViewPath);\n                        this.CURRENT_SUPER_VIEW_MOUNTED = true;\n                    } else { // náº¿u cáº§n insert content vÃ o html thÃ¬ set trang thÃ¡i super view mounted = false vÃ  render super view\n                        this.CURRENT_SUPER_VIEW_PATH = superViewPath;\n                        this.CURRENT_SUPER_VIEW = superView;\n                        // this.CURRENT_SUPER_VIEW_MOUNTED = false;\n                        html = superView.render();\n                        // console.log('ðŸ” App.View.loadView render super view:', html);\n\n\n                    }\n                }\n                // console.log('ðŸ” App.View.loadView need insert:', needInsert);\n                // console.log('ðŸ” App.View.loadView return in try');\n                return {\n                    html: html,\n                    isSuperView: superViewPath ? true : false,\n                    needInsert: needInsert,\n                    superView: superView,\n                    ultraView: ultraView,\n                    error: null\n                };\n\n            } catch (error) {\n                message = 'App.View.loadView: Error updating DOM:', error;\n\n            }\n\n            // console.log(`ðŸŽ‰ App.View.loadView: Successfully loaded view '${name}'`);\n\n        } catch (error) {\n            message = `App.View.loadView: Critical error loading view '${name}':`, error;\n\n        }\n        return {\n            html: null,\n            needInsert: false,\n            superView: null,\n            ultraView: null,\n            isSuperView: false,\n            error: message\n        };\n    }\n\n\n    scanView(name, route = null) {\n        if (this.templates[name]) {\n            this.clearOldRendering();\n        }\n        this.renderTimes++;\n        let message = null;\n        this.CURRENT_SUPER_VIEW_MOUNTED = false;\n        try {\n            const viewData = this.ssrViewManager.scan(name);\n            if (!viewData) {\n                message = `App.View.scanView: View '${name}' not found`;\n                return {\n                    error: `App.View.scanView: View '${name}' not found`,\n                    html: null,\n                    superView: null,\n                    isSuperView: false,\n                    needInsert: false,\n                };\n            }\n            const data = viewData.data;\n            data.__SSR_VIEW_ID__ = viewData.viewId;\n            // console.log('ðŸ” App.View.scanView called with:', name, data);\n\n            // Get view from templates\n            let view = this.view(name, data);\n            if (!view) {\n                message = `App.View.loadView: View '${name}' not found`;\n                return {\n                    error: `App.View.loadView: View '${name}' not found`,\n                    html: null,\n                    superView: null,\n                    isSuperView: false,\n                    needInsert: false,\n                };\n            }\n            if (route && route.$urlPath) {\n                view.urlPath = route.$urlPath;\n            }\n\n\n            // Store view in array for tracking\n            let superView = null;\n            let superViewPath = null;\n            let result;\n            let currentViewPath = view.path;\n            let currentView = view;\n            let ultraView = view;\n            this.PAGE_VIEW = view;\n            view.__scan(viewData);\n            // vÃ²ng láº·p Ä‘á»ƒ render view cho Ä‘áº¿n khi khÃ´ng cÃ³ super view hoáº·c khÃ´ng cÃ³ super view thÃ¬ render view\n            let renderIndex = 0;\n            do {\n                try {\n\n                    // kiá»ƒm tra view cÃ³ super view khÃ´ng\n                    if (view.hasSuperView) {\n\n                        this.ALL_VIEW_STACK.unshift(view);\n                        superViewPath = view.superViewPath;\n                        result = this.scanRenderedView(view);\n                        view = result;\n                        view.setIsSuperView(true);\n                        if (view && typeof view === 'object') {\n                            superView = view;\n                            ultraView = view;\n                            if (!view.isScanned) {\n\n                                // ============================================================\n                                // CRITICAL FIX: Scan super view DOM + attach events\n                                // ============================================================\n                                // Get super view SSR data and scan it\n                                const superViewData = this.ssrViewManager.scan(superViewPath);\n                                if (superViewData) {\n                                    // logger.log(`ðŸ” View.scanView: Scanning super view ${superViewPath}`);\n                                    superView.__scan(superViewData);\n                                    // logger.log(`âœ… View.scanView: Super view ${superViewPath} scanned`);\n                                } else {\n                                    // logger.warn(`âš ï¸ View.scanView: No SSR data for super view ${superViewPath}`);\n                                }\n                            }\n                        }\n                        // console.log('ðŸ” App.View.scanView super view:', view);\n                    }\n                    // kiá»ƒm tra view cÃ³ pháº£i lÃ  super view khÃ´ng\n                    else if (view.isSuperView) {\n                        if (superViewPath !== view.path) {\n                            this.SUPER_VIEW_STACK.unshift(view);\n                            superViewPath = view.path;\n                            ultraView = view;\n                        }\n\n                        superView = view;\n                        ultraView = view;\n                        // console.log('ðŸ” App.View.scanView is super view:', view.path);\n                        if (view.hasSuperView) {\n                            result = this.scanRenderedView(view);\n                            view = result;\n                            view.setIsSuperView(true);\n                            if (view && typeof view === 'object') {\n                                superView = view;\n                                superViewPath = view.path;\n                                ultraView = view;\n                                if (!view.isScanned) {\n                                    // ============================================================\n                                    // CRITICAL FIX: Scan nested super view\n                                    // ============================================================\n                                    const nestedSuperViewData = this.ssrViewManager.scan(superViewPath);\n                                    if (nestedSuperViewData) {\n                                        // logger.log(`ðŸ” View.scanView: Scanning nested super view ${superViewPath}`);\n                                        superView.__scan(nestedSuperViewData);\n                                        // logger.log(`âœ… View.scanView: Nested super view ${superViewPath} scanned`);\n                                    }\n                                }\n                            }\n                        } else {\n                            result = '';// náº¿u lÃ  super view thÃ¬ khÃ´ng cáº§n thÃªm vÃ o queue vÃ  khÃ´ng render. Ä‘á»ƒ bÆ°á»›c sau xá»­ lÃ½\n                        }\n                    }\n                    // náº¿u khÃ´ng cÃ³ super view vÃ  khÃ´ng pháº£i lÃ  super view thÃ¬ render view\n                    else {\n                        this.ALL_VIEW_STACK.unshift(view);\n                        this.PAGE_VIEW = view;\n                        // console.log('ðŸ” App.View.scanView normal view:', view.path);\n                        result = this.scanRenderedView(view);\n                        ultraView = view;\n                    }\n                } catch (error) {\n                    message = `App.View.scanView: Error rendering view '${name}':`, error;\n                    console.error('ðŸ” App.View.scanView error:', error);\n                    return '';\n                }\n                renderIndex++;\n            } while (result && typeof result === 'object' && result.constructor === this.Engine)\n            // Update #spa-root with the final string\n            // console.log(\"view after check\", { currentViewPath, superViewPath })\n            try {\n                let html = result;\n                // diá»ƒu kiá»…n cÃ³ cáº§n insert content vÃ o html khÃ´ng\n                const needInsert = !(superViewPath && superViewPath === this.CURRENT_SUPER_VIEW_PATH);\n                if (superViewPath) {\n                    // kiá»ƒm tra view cÃ³ pháº£i lÃ  super view khÃ´ng\n                    if (!needInsert) { // náº¿u khÃ´ng cáº§n insert content vÃ o html thÃ¬ set trang thÃ¡i super view mounted = true\n                        console.log('ðŸ” App.View.scanView need insert super view:', superViewPath);\n                        this.CURRENT_SUPER_VIEW_MOUNTED = true;\n                    } else { // náº¿u cáº§n insert content vÃ o html thÃ¬ set trang thÃ¡i super view mounted = false vÃ  render super view\n                        this.CURRENT_SUPER_VIEW_PATH = superViewPath;\n                        this.CURRENT_SUPER_VIEW = superView;\n                        this.CURRENT_SUPER_VIEW_MOUNTED = false;\n                        html = superView.virtualRender();\n                        console.log('ðŸ” App.View.scanView render super view:', html);\n\n\n                    }\n                }\n\n                // ============================================================\n                // LIFECYCLE: Mount all views in bottom-up order\n                // ============================================================\n                // After scanning and virtual render complete, mount all views\n                // in reverse order (deepest layout â†’ page view)\n                this.mountAllViewsFromStack(this.renderTimes).then(() => {\n                    logger.log('âœ… View.scanView: All views mounted successfully in bottom-up order');\n                }).catch(error => {\n                    logger.error('âŒ View.scanView: Error mounting views:', error);\n                });\n\n                return {\n                    html: html,\n                    isSuperView: superViewPath ? true : false,\n                    needInsert: needInsert,\n                    superView: superView,\n                    ultraView: ultraView,\n                    error: null\n                };\n\n            } catch (error) {\n                message = 'App.View.scanView: Error updating DOM:' + error.message;\n\n            }\n\n            // console.log(`ðŸŽ‰ App.View.scanView: Successfully loaded view '${name}'`);\n\n        } catch (error) {\n            message = `App.View.scanView: Critical error loading view '${name}':` + error.message;\n\n        }\n        return {\n            html: null,\n            needInsert: false,\n            superView: null,\n            isSuperView: false,\n            ultraView: null,\n            error: message\n        };\n    }\n\n    mountView(viewName, params = {}, route = null) {\n        try {\n            let currentSuperView = this.CURRENT_SUPER_VIEW;\n            if (currentSuperView && currentSuperView instanceof ViewEngine) {\n                currentSuperView.unmounted();\n            }\n            const viewResult = this.loadView(viewName, params, route?.$urlPath || '');\n            if (viewResult.error) {\n                console.error('View rendering error:', viewResult.error);\n                return;\n            }\n            console.log('View rendered successfully:', viewResult);\n\n            if (viewResult.needInsert && viewResult.html) {\n                const container = this.container || document.querySelector('#app-root') || document.querySelector('#app') || document.body;\n                const html = viewResult.html\n                if (container) {\n                    OneDOM.setHTML(container, html);\n                }\n            } else {\n                console.log('Router: Not updating DOM - needInsert:', viewResult.needInsert, 'html:', !!viewResult.html);\n            }\n\n            // Emit changed sections\n            if (this.emitChangedSections) {\n                this.emitChangedSections();\n            }\n\n            if (viewResult.ultraView && viewResult.ultraView instanceof ViewEngine) {\n                viewResult.ultraView.mounted();\n            }\n            this.CURRENT_SUPER_VIEW_MOUNTED = true; // set trang thÃ¡i super view mounted = true\n\n\n        } catch (error) {\n            console.error('Error rendering view:', error);\n        }\n    }\n\n    mountViewScan(viewName, params = {}, route = null) {\n\n        // ============================================================\n        // CORE HYDRATION: Scan SSR HTML and attach JS behavior\n        // ============================================================\n        // scanView() will:\n        // 1. Parse SSR data from HTML comments\n        // 2. Create view instances (page + layouts)\n        // 3. Call virtualRender() to setup relationships\n        // 4. Scan DOM and attach event handlers\n        // 5. Setup state subscriptions\n        // 6. Mount all views in bottom-up order (deepest layout â†’ page)\n        const scanResult = this.scanView(viewName);\n        // console.log(scanResult);\n        if (scanResult.error) {\n            console.error('âŒ Router.hydrateViews: Scan error:', scanResult.error);\n            return;\n        }\n\n        if (scanResult.ultraView && scanResult.ultraView instanceof ViewEngine) {\n            scanResult.ultraView.mounted();\n        }\n        this.CURRENT_SUPER_VIEW_MOUNTED = true; // set trang thÃ¡i super view mounted = true\n        this._isHydrated = true;\n    }\n\n\n    mountContent(htmlContent) {\n        const container = this.container || document.querySelector('#app-root') || document.querySelector('#app') || document.body;\n        if (container) {\n            OneDOM.setHTML(container, htmlContent);\n        }\n    }\n\n\n    // ============================================================================\n    // EVENT FUNCTIONS\n    // ============================================================================\n\n\n    on(event, callback) {\n        if (typeof event !== 'string' || event === '') {\n            return false;\n        }\n        if (typeof callback !== 'function') {\n            return false;\n        }\n        if (!this.listeners[event]) {\n            this.listeners[event] = [];\n        }\n        this.listeners[event].push(callback);\n    }\n    off(event, callback) {\n        if (typeof event !== 'string' || event === '') {\n            return false;\n        }\n        if (typeof callback !== 'function') {\n            return false;\n        }\n        if (!this.listeners[event]) {\n            return;\n        }\n        this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    }\n    emit(event, ...args) {\n        if (typeof event !== 'string' || event === '') {\n            return false;\n        }\n        if (!this.listeners[event]) {\n            return;\n        }\n        this.listeners[event].forEach(callback => callback(...args));\n    }\n    // ============================================================================\n    // CORE FUNCTIONS\n    // ============================================================================\n\n    /**\n     * Generate unique view ID\n     * @returns {string} UUID v4\n     */\n    generateViewId() {\n        return uniqId();\n    }\n\n    /**\n     * Execute function and return result\n     * @param {Function} fn - Function to execute\n     * @returns {string} Result as string\n     */\n    execute(fn, defaultValue = '') {\n        try {\n            const result = fn();\n            return result !== undefined ? result : defaultValue;\n        } catch (error) {\n            logger.error('App.execute error:', error);\n            return defaultValue;\n        }\n    }\n\n    evaluate(fn, defaultValue = '') {\n        try {\n            const result = fn();\n            return result !== undefined ? result : defaultValue;\n        } catch (error) {\n            logger.error('App.evaluate error:', error);\n            return defaultValue;\n        }\n    }\n    /**\n     * Escape string for HTML output\n     * @param {*} value - Value to escape\n     * @returns {string} Escaped string\n     */\n    escString(value) {\n        if (value === null || value === undefined) {\n            return '';\n        }\n\n        const str = String(value);\n        return str\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    }\n\n    /**\n     * Get text content (for preloader messages)\n     * @param {string} key - Text key\n     * @returns {string} Text content\n     */\n    text(key) {\n        const texts = {\n            'loading': 'Loading...',\n            'error': 'Error occurred',\n            'not_found': 'Not found',\n            'unauthorized': 'Unauthorized'\n        };\n\n        return texts[key] || key;\n    }\n\n\n    // ============================================================================\n    // INIT FUNCTIONS\n    // ============================================================================\n    setSuperViewPath(superView) {\n        this.CURRENT_SUPER_VIEW_PATH = superView;\n    }\n    addViewEngine(renderTimes, viewEngine) {\n        if (typeof this.VIEW_MOUNTED_QUEUE[renderTimes] === 'undefined') {\n            this.VIEW_MOUNTED_QUEUE[renderTimes] = [];\n        }\n        this.VIEW_MOUNTED_QUEUE[renderTimes].push(viewEngine);\n    }\n    /**\n     * Gá»i hÃ m mounted cá»§a ViewEngine\n     * @param {number} renderTimes - Sá»‘ láº§n render hiá»‡n táº¡i (dÃ¹ng lÃ m key cho queue).\n     * @param {string} viewEngineId - ID cá»§a ViewEngine cáº§n gá»i hÃ m mounted.\n     */\n    callViewEngineMounted(renderTimes, viewEngineId) {\n        return;\n    }\n\n    /**\n     * Mount all views in bottom-up order (last â†’ first)\n     * This ensures parent views mount after their children\n     *\n     * Flow:\n     * 1. Layout View 2 (deepest) mounted first\n     * 2. Layout View 1 mounted\n     * 3. Included views mounted\n     * 4. First View (page view) mounted last\n     *\n     * @param {number} renderTimes - Sá»‘ láº§n render hiá»‡n táº¡i\n     * @returns {Promise<void>}\n     */\n    async mountAllViewsBottomUp(renderTimes) {\n        // logger.log(`ðŸ”„ View.mountAllViewsBottomUp: Starting bottom-up mounting for renderTimes=${renderTimes}`);\n\n        // Check if queue exists and has views\n        if (!this.VIEW_MOUNTED_QUEUE[renderTimes] || !this.VIEW_MOUNTED_QUEUE[renderTimes].length) {\n            logger.warn(`âš ï¸ View.mountAllViewsBottomUp: No views in queue for renderTimes=${renderTimes}`);\n            return;\n        }\n\n        // Wait for super view to be ready\n        if (!this.CURRENT_SUPER_VIEW_MOUNTED) {\n            logger.log(`â³ View.mountAllViewsBottomUp: Waiting for super view to be mounted...`);\n            await new Promise(resolve => {\n                const checkInterval = setInterval(() => {\n                    if (this.CURRENT_SUPER_VIEW_MOUNTED) {\n                        clearInterval(checkInterval);\n                        resolve();\n                    }\n                }, 50); // Check every 50ms (faster than 100ms)\n            });\n        }\n\n        // Get queue for this render\n        const queue = this.VIEW_MOUNTED_QUEUE[renderTimes];\n        logger.log(`ðŸ“‹ View.mountAllViewsBottomUp: Processing ${queue.length} views`);\n\n        // Mount in reverse order (bottom-up: last â†’ first)\n        // This ensures deepest layouts mount first, then parent views\n        for (let i = queue.length - 1; i >= 0; i--) {\n            const viewEngine = queue[i];\n\n            try {\n                // logger.log(`ðŸŽ¯ View.mountAllViewsBottomUp: Mounting view ${i + 1}/${queue.length} - ${viewEngine.path} (${viewEngine.id})`);\n\n                // Call beforeMount lifecycle\n                if (typeof viewEngine.beforeMount === 'function') {\n                    viewEngine.beforeMount();\n                }\n\n                // Call mounted lifecycle\n                if (typeof viewEngine.mounted === 'function') {\n                    viewEngine.mounted();\n                }\n\n                logger.log(`âœ… View.mountAllViewsBottomUp: Successfully mounted ${viewEngine.path}`);\n            } catch (error) {\n                logger.error(`âŒ View.mountAllViewsBottomUp: Error mounting ${viewEngine.path}:`, error);\n                // Continue mounting other views even if one fails\n            }\n        }\n\n        // Clear the queue after mounting all views\n        this.VIEW_MOUNTED_QUEUE[renderTimes] = [];\n        // logger.log(`âœ… View.mountAllViewsBottomUp: All views mounted successfully, queue cleared`);\n    }\n\n    /**\n     * Mount all views using stack-based order\n     * Uses ALL_VIEW_STACK which is built during scanView\n     * Order: super views first (bottom), then included views, then page view (top)\n     *\n     * @param {number} renderTimes - Sá»‘ láº§n render hiá»‡n táº¡i\n     * @returns {Promise<void>}\n     */\n    async mountAllViewsFromStack(renderTimes) {\n        // logger.log(`ðŸ”„ View.mountAllViewsFromStack: Starting stack-based mounting`);\n\n        // Check if we have views in queue\n        if (!this.VIEW_MOUNTED_QUEUE[renderTimes] || !this.VIEW_MOUNTED_QUEUE[renderTimes].length) {\n            logger.warn(`âš ï¸ View.mountAllViewsFromStack: No views in queue`);\n            return;\n        }\n\n        // Wait for super view to be ready\n        if (!this.CURRENT_SUPER_VIEW_MOUNTED) {\n            logger.log(`â³ View.mountAllViewsFromStack: Waiting for super view...`);\n            await new Promise(resolve => {\n                const checkInterval = setInterval(() => {\n                    if (this.CURRENT_SUPER_VIEW_MOUNTED) {\n                        clearInterval(checkInterval);\n                        resolve();\n                    }\n                }, 50);\n            });\n        }\n\n        // If we have a stack (from scanView), use it for ordering\n        if (this.ALL_VIEW_STACK && this.ALL_VIEW_STACK.length > 0) {\n            // logger.log(`ðŸ“š View.mountAllViewsFromStack: Using ALL_VIEW_STACK (${this.ALL_VIEW_STACK.length} views)`);\n\n            // Mount super views first (they're at the beginning of stack)\n            const superViews = this.SUPER_VIEW_STACK || [];\n            for (let i = superViews.length - 1; i >= 0; i--) {\n                const viewEngine = superViews[i];\n                try {\n                    // logger.log(`ðŸ›ï¸ View.mountAllViewsFromStack: Mounting super view ${viewEngine.path}`);\n                    if (typeof viewEngine.beforeMount === 'function') {\n                        viewEngine.beforeMount();\n                    }\n                    if (typeof viewEngine.mounted === 'function') {\n                        viewEngine.mounted();\n                    }\n                    // logger.log(`âœ… Mounted super view: ${viewEngine.path}`);\n                } catch (error) {\n                    logger.error(`âŒ Error mounting super view ${viewEngine.path}:`, error);\n                }\n            }\n\n            // Then mount page view and its includes (from ALL_VIEW_STACK)\n            for (let i = this.ALL_VIEW_STACK.length - 1; i >= 0; i--) {\n                const viewEngine = this.ALL_VIEW_STACK[i];\n\n                // Skip if already mounted as super view\n                if (superViews.includes(viewEngine)) {\n                    continue;\n                }\n\n                try {\n                    // logger.log(`ðŸ“„ View.mountAllViewsFromStack: Mounting view ${viewEngine.path}`);\n                    if (typeof viewEngine.beforeMount === 'function') {\n                        viewEngine.beforeMount();\n                    }\n                    if (typeof viewEngine.mounted === 'function') {\n                        viewEngine.mounted();\n                    }\n                    // logger.log(`âœ… Mounted view: ${viewEngine.path}`);\n                } catch (error) {\n                    logger.error(`âŒ Error mounting view ${viewEngine.path}:`, error);\n                }\n            }\n\n            // Clear stacks\n            this.ALL_VIEW_STACK = [];\n            this.SUPER_VIEW_STACK = [];\n            // logger.log(`âœ… View.mountAllViewsFromStack: Stack-based mounting complete`);\n        } else {\n            // Fallback to bottom-up queue mounting\n            // logger.log(`âš ï¸ View.mountAllViewsFromStack: No stack available, falling back to queue mounting`);\n            await this.mountAllViewsBottomUp(renderTimes);\n        }\n\n        // Clear the queue\n        this.VIEW_MOUNTED_QUEUE[renderTimes] = [];\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    templateToDom(template) {\n        /**\n         * @type {HTMLTemplateElement}\n         */\n        const templator = document.createElement('template');\n        templator.innerHTML = template;\n        return templator.content.firstChild;\n    }\n\n\n\n    /**\n     * Include a view\n     * @param {string} viewName - Name of the view to include\n     * @param {Object} data - Data to pass to the view\n     * @returns {string} Rendered view content\n     */\n    include(viewName, data = {}) {\n        try {\n            const view = this.view(viewName, { ...data }, false);\n            return view;\n        } catch (error) {\n            console.error(`App.View.include error for '${viewName}':`, error);\n            return '';\n        }\n    }\n\n    /**\n     * Include a view if it exists\n     * @param {string} viewName - Name of the view to include\n     * @param {Object} data - Data to pass to the view\n     * @returns {string} Rendered view content or empty string\n     */\n    includeIf(viewName, data = {}) {\n        try {\n            return this.exists(viewName) ? this.include(viewName, data) : null;\n        } catch (error) {\n            console.error(`App.View.includeIf error for '${viewName}':`, error);\n            return null;\n        }\n    }\n\n    /**\n     * Extend a view (for @extends directive)\n     * @param {string} superViewName - Name of the parent view\n     * @param {Object} data - Data to pass to the parent view\n     * @returns {App.View.Engine} View Engine\n     */\n    extendView(superViewName, data = {}) {\n        try {\n            const view = this.view(superViewName, hasData(data) ? data : null, true);\n            if (!view) {\n                // console.warn(`App.View.extendView: Parent view '${superViewName}' not found`);\n                return null;\n            }\n            this.cachedViews[superViewName] = view;\n            return this.cachedViews[superViewName];\n\n        } catch (error) {\n            // console.error(`App.View.extendView error for '${superViewName}':`, error);\n            return null;\n        }\n    }\n\n\n    registerSubscribe(attr, yieldKey, defaultContent = '') {\n        let output = '';\n        const subscribeAttr = [];\n        if (typeof attr === 'string') {\n            output += ` ${attr}=\"${this.yieldContent(yieldKey, defaultContent)}\"`;\n            subscribeAttr.push(`${attr}:${yieldKey}`);\n        }\n        else if (typeof attr === 'object') {\n            const keys = Object.keys(attr);\n            for (const key of keys) {\n                if (key.toLowerCase() === '#content') {\n                    output += ` ${ATTR.KEYS.YIELD_CONTENT}=\"${attr[key]}\"`;\n                }\n                else if (key.toLowerCase() === '#children') {\n                    output += ` ${ATTR.KEYS.YIELD_CHILDREN}=\"${attr[key]}\"`;\n                }\n                else {\n                    output += ` ${key}=\"${this.yieldContent(attr[key], defaultContent)}\"`;\n                    subscribeAttr.push(`${key}:${attr[key]}`);\n                }\n            }\n        }\n        output += ` ${ATTR.KEYS.YIELD_ATTR}=\"${subscribeAttr.join(',')}\"`;\n        return output;\n    }\n\n    exists(viewName) {\n        return this.templates && this.templates[viewName] ? true : false;\n    }\n\n    // ========================================================================\n    // RENDER/SCAN METHODS - OPTIMIZED\n    // ========================================================================\n\n    /**\n     * Unified view rendering/scanning method\n     *\n     * @param {ViewEngine} view - View engine instance\n     * @param {Object} variableData - Variable data to pass to the view\n     * @param {string} mode - Render mode: 'csr' (render) or 'ssr' (virtualRender)\n     * @returns {string|ViewEngine} Rendered content or ViewEngine for extends\n     *\n     * @description\n     * Handles both CSR (Client-Side Rendering) and SSR (Server-Side Scanning):\n     * - CSR mode: Calls render(), prerender() for actual HTML generation\n     * - SSR mode: Calls virtualRender(), virtualPrerender() for relationship setup\n     *\n     * Async Data Handling:\n     * - @await('client'): Loads data from current URL via getURIDAta()\n     * - @fetch(url, data, headers): Loads data using custom fetch config\n     *\n     * Note: virtualRender/virtualPrerender do NOT generate HTML!\n     * They only setup view hierarchy, sections, state subscriptions, and prepare for hydration.\n     */\n    renderOrScanView(view, variableData = null, mode = 'csr') {\n        let result = null;\n        const renderTimes = this.renderTimes;\n\n\n        // Determine render methods based on mode\n        // CSR: render() generates HTML\n        // SSR: virtualRender() only sets up relationships (NO HTML)\n        const renderMethod = mode === 'ssr' ? 'virtualRender' : 'render';\n        const prerenderMethod = mode === 'ssr' ? 'virtualPrerender' : 'prerender';\n\n        // ====================================================================\n        // CASE 1: No async data - simple render/scan\n        // ====================================================================\n        if (!(view.hasAwaitData || view.hasFetchData)) {\n            if (variableData) {\n                view.updateVariableData({ ...variableData });\n            }\n            result = view[renderMethod]();\n\n            return result;\n        }\n\n        // ====================================================================\n        // CASE 2: Has async data but no prerender\n        // ====================================================================\n        const isPrerender = view.hasPrerender;\n        if (!isPrerender) {\n            if (variableData) {\n                view.updateVariableData(variableData);\n            }\n            result = view[renderMethod]();\n        }\n\n        // ====================================================================\n        // CASE 3A: Has @await - Load data by current URL\n        // ====================================================================\n        if (view.hasAwaitData) {\n            // First: Show prerender (loading state)\n            if (isPrerender) {\n                result = view[prerenderMethod]();\n            }\n\n            // Handle based on mode\n            if (mode === 'csr') {\n                // CSR: Load data from current URL then re-render\n                this.App.API.getURIDAta().then(data => {\n\n                    view.updateVariableData(data);\n                    // Re-render with loaded data\n                    view[renderMethod]();\n\n                });\n            } else {\n                // SSR: Just setup relationships (no data loading needed)\n                result = view[renderMethod]();\n\n                if (addToQueue) {\n                    this.callViewEngineMounted(renderTimes, view.id);\n                }\n            }\n        }\n\n        // ====================================================================\n        // CASE 3B: Has @fetch - Load data by fetch config\n        // ====================================================================\n        else if (view.hasFetchData) {\n            // First: Show prerender (loading state)\n            if (isPrerender) {\n                result = view[prerenderMethod]();\n            }\n\n            // Handle based on mode\n            if (mode === 'csr') {\n                // CSR: Fetch data using config (url, method, data, headers)\n                const fetchConfig = view.fetch || {};\n                // TODO: Implement fetch logic with config\n                // this.App.API.fetch(fetchConfig).then(data => {\n                //     view[renderMethod]();\n                //     if (addToQueue) {\n                //         this.callViewEngineMounted(renderTimes, view.id);\n                //     }\n                // });\n\n                // Temporary: Use same as await until fetch is implemented\n                this.App.API.getURIDAta().then(data => {\n                    view.updateVariableData(data);\n                    view[renderMethod]();\n                    if (addToQueue) {\n                        this.callViewEngineMounted(renderTimes, view.id);\n                    }\n                });\n            } else {\n                // SSR: Just setup relationships (no data loading needed)\n                result = view[renderMethod]();\n\n                if (addToQueue) {\n                    this.callViewEngineMounted(renderTimes, view.id);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Render a view (CSR - Client-Side Rendering)\n     *\n     * Generates actual HTML content by calling:\n     * - view.render() - Returns HTML string\n     * - view.prerender() - Returns loading state HTML\n     *\n     * @param {ViewEngine} view - View engine\n     * @param {Object} variableData - Variable data to pass to the view\n     * @returns {string} Rendered HTML content\n     */\n    renderView(view, variableData = null) {\n        return this.renderOrScanView(view, variableData, 'csr');\n    }\n\n    /**\n     * Scan rendered view (SSR - Server-Side Scanning)\n     *\n     * DOES NOT generate HTML - only sets up relationships by calling:\n     * - view.virtualRender() - Setup hierarchy, sections, state (NO HTML)\n     * - view.virtualPrerender() - Setup loading relationships (NO HTML)\n     *\n     * Purpose of virtual methods:\n     * 1. Setup view hierarchy (extends/includes)\n     * 2. Register sections with parent views\n     * 3. Setup state subscriptions for reactive blocks\n     * 4. Prepare view instances for DOM hydration\n     * 5. Map server data to client view structure\n     *\n     * @param {ViewEngine} view - View engine\n     * @param {Object} variableData - Variable data to pass to the view\n     * @returns {ViewEngine} ViewEngine instance for extends chain\n     */\n    scanRenderedView(view, variableData = null) {\n        return this.renderOrScanView(view, variableData, 'ssr');\n    }\n\n    /**\n     * Render a view by name\n     * @param {string} name - View name\n     * @param {Object} data - Data to pass to view\n     * @param {string} scope - View scope\n     * @returns {ViewEngine|null} Rendered view content\n     */\n    view(name, data = null, cache = false) {\n        try {\n            // check if view is cached\n            if (cache && this.cachedViews[name]) {\n                const view = this.cachedViews[name];\n                view.reset();\n                if (data) {\n                    view.updateVariableData({ ...data });\n                }\n                return view;\n            }\n            // check if view is valid\n            if (!this.templates[name]) {\n                console.warn(`App.View.view: View '${name}' not found in scope '${scope}'`);\n                return null;\n            }\n            // check if view is valid\n            if (typeof this.templates[name] !== 'function') {\n                console.warn(`App.View.view: View '${name}' render function is not valid`);\n                return null;\n            }\n\n            // get view wrapper\n            const viewWrapper = this.templates[name];\n            // create view\n            const view = viewWrapper(data ? { ...data } : {}, { App: this.App, View: this });\n            // view.updateVariableData(data);\n            // check if view is valid\n            if (!view) {\n                console.error(`App.View.view: View config not found for '${name}' in scope '${scope}'`);\n                return null;\n            }\n\n            view.setApp(this.App);\n            // cache view\n            this.cachedViews[name] = view;\n            return view;\n\n        } catch (error) {\n            console.error(`App.View.view: Critical error loading view '${name}':`, error);\n            return null;\n        }\n    };\n\n\n    /**\n     * Clear old rendering data and cleanup memory\n     * Called before each new render to prevent memory leaks\n     *\n     * Cleanup tasks:\n     * 1. Remove old views from previous render cycles\n     * 2. Clear event listeners from unmounted views\n     * 3. Cleanup old render queues (keep only last 3 cycles)\n     * 4. Trim view cache if too large (LRU eviction)\n     */\n    clearOldRendering() {\n        const currentRenderTime = this.renderTimes;\n\n        // ================================================================\n        // 1. Cleanup old render queues (keep only last 3 cycles)\n        // ================================================================\n        if (currentRenderTime > 3) {\n            const oldRenderTime = currentRenderTime - 3;\n            if (this.VIEW_MOUNTED_QUEUE[oldRenderTime]) {\n                // logger.log(`ðŸ—‘ï¸ View.clearOldRendering: Cleaning queue for renderTime=${oldRenderTime}`);\n\n                // Unmount views from old queue\n                const oldViews = this.VIEW_MOUNTED_QUEUE[oldRenderTime];\n                if (Array.isArray(oldViews)) {\n                    oldViews.forEach(view => {\n                        if (view && typeof view === 'object') {\n                            this.unmountView(view);\n                        }\n                    });\n                }\n\n                // Delete old queue\n                delete this.VIEW_MOUNTED_QUEUE[oldRenderTime];\n            }\n        }\n\n        // ================================================================\n        // 2. Trim view cache if too large (LRU: max 50 views)\n        // ================================================================\n        const MAX_CACHED_VIEWS = 50;\n        const cachedKeys = Object.keys(this.cachedViews);\n        if (cachedKeys.length > MAX_CACHED_VIEWS) {\n            // logger.log(`ðŸ—‘ï¸ View.clearOldRendering: Cache too large (${cachedKeys.length}), trimming to ${MAX_CACHED_VIEWS}`);\n\n            // Remove oldest views (simple strategy: remove first N)\n            const toRemove = cachedKeys.slice(0, cachedKeys.length - MAX_CACHED_VIEWS);\n            toRemove.forEach(key => {\n                const view = this.cachedViews[key];\n                if (view) {\n                    this.unmountView(view);\n                }\n                delete this.cachedViews[key];\n            });\n        }\n        this.ALL_VIEW_STACK = [];\n        this.SUPER_VIEW_STACK = [];\n        this.PAGE_VIEW = null;\n\n        // ================================================================\n        // 3. Clear orphaned event data to prevent memory leaks\n        // ================================================================\n        this.clearOrphanedEventData();\n    }\n\n\n\n    /**\n     * Unmount a view and cleanup its resources\n     *\n     * @param {ViewEngine} view - View to unmount\n     * @returns {boolean} Success status\n     *\n     * @description\n     * Properly cleanup a view by:\n     * 1. Call beforeUnmount() lifecycle hook\n     * 2. Remove event listeners via removeEvents()\n     * 3. Remove from viewMap\n     * 4. Call unmounted() lifecycle hook\n     * 5. Call destroy() if defined\n     */\n    unmountView(view) {\n        if (!view || typeof view !== 'object') {\n            logger.warn('âš ï¸ View.unmountView: Invalid view object');\n            return false;\n        }\n\n        try {\n            logger.log(`ðŸ—‘ï¸ View.unmountView: Unmounting view ${view.id} (${view.path})`);\n\n            // Step 1: Call beforeUnmount lifecycle\n            if (typeof view.beforeUnmount === 'function') {\n                view.beforeUnmount();\n            }\n\n            // Step 2: Remove event listeners\n            if (typeof view.removeEvents === 'function') {\n                view.removeEvents();\n            }\n\n            // Step 3: Remove from viewMap\n            if (this.viewMap.has(view.id)) {\n                this.viewMap.delete(view.id);\n            }\n\n            // Step 4: Call unmounted lifecycle\n            if (typeof view.unmounted === 'function') {\n                view.unmounted();\n            }\n\n            // Step 5: Call destroy if defined\n            if (typeof view.destroy === 'function') {\n                view.destroy();\n            }\n\n            logger.log(`âœ… View.unmountView: View ${view.id} unmounted successfully`);\n            return true;\n\n        } catch (error) {\n            logger.error(`âŒ View.unmountView: Error unmounting view ${view.id}:`, error);\n            return false;\n        }\n    }\n\n    /**\n     * Reset view state\n     * Clears view stacks but does NOT unmount views\n     * Use clearOldRendering() for proper cleanup\n     */\n    resetView() {\n        logger.log('ðŸ”„ View.resetView: Resetting view stacks');\n        this.SUPER_VIEW_STACK = [];\n        this.ALL_VIEW_STACK = [];\n        this.PAGE_VIEW = null;\n\n    }\n\n    /**\n     * Clear orphaned event data from all views\n     * Call this when DOM changes significantly to prevent memory leaks\n     */\n    clearOrphanedEventData() {\n        logger.log('ðŸ—‘ï¸ View.clearOrphanedEventData: Cleaning up orphaned event handlers');\n\n        // Clear from all cached views\n        Object.values(this.cachedViews).forEach(view => {\n            if (view && typeof view.clearOrphanedEventData === 'function') {\n                view.clearOrphanedEventData();\n            }\n        });\n\n        // Clear from current views in stacks\n        [...this.ALL_VIEW_STACK, ...this.SUPER_VIEW_STACK].forEach(view => {\n            if (view && typeof view.clearOrphanedEventData === 'function') {\n                view.clearOrphanedEventData();\n            }\n        });\n\n        // Clear from current view\n        if (this.CURRENT_VIEW && typeof this.CURRENT_VIEW.clearOrphanedEventData === 'function') {\n            this.CURRENT_VIEW.clearOrphanedEventData();\n        }\n\n        if (this.CURRENT_SUPER_VIEW && typeof this.CURRENT_SUPER_VIEW.clearOrphanedEventData === 'function') {\n            this.CURRENT_SUPER_VIEW.clearOrphanedEventData();\n        }\n    }\n\n\n    // ============================================================================\n    // SECTION FUNCTIONS\n    // ============================================================================\n\n\n    /**\n     * Define a section\n     * @param {string} name - Section name\n     * @param {string} content - Section content\n     * @param {string} type - Section type\n     */\n    section(name, content, type = 'string') {\n        let oldContent = this._sections[name];\n        this._sections[name] = content;\n        if (oldContent !== content) {\n            this._changedSections.push(name);\n        }\n    };\n\n    /**\n     * Yield a section content\n     * @param {string} name - Section name\n     * @param {string} defaultContent - Default content if section not found\n     * @returns {string} Section content\n     */\n    yield(name, defaultContent = '') {\n        return this._sections[name] || defaultContent;\n    }\n    yieldContent(name, defaultContent = '') {\n        return this._sections[name] || defaultContent;\n    }\n\n\n    /**\n     * Render all sections as HTML\n     * @returns {string} Rendered sections HTML\n     */\n    renderSections() {\n        let html = '';\n        for (const [name, content] of Object.entries(this._sections)) {\n            html += content;\n        }\n        return html;\n    }\n\n    /**\n     * Check if section exists\n     * @param {string} name - Section name\n     * @returns {boolean} True if section exists\n     */\n    hasSection(name) {\n        return name in this._sections;\n    }\n\n    /**\n     * Get changed sections\n     * @returns {string[]} Changed sections\n     */\n    getChangedSections() {\n        return this._changedSections;\n    };\n\n    /**\n     * Reset changed sections list\n     */\n    resetChangedSections() {\n        this._changedSections = [];\n    };\n\n    /**\n     * Check if section has changed\n     * @param {string} name - Section name\n     * @returns {boolean} True if section has changed\n     */\n    isChangedSection(name) {\n        return this._changedSections.includes(name);\n    };\n\n\n    /**\n     * Emit changed sections to subscribed elements\n     */\n    emitChangedSections() {\n        this._changedSections.forEach(name => {\n            if (this.SEO.updateItem(name, this._sections[name])) {\n                return;\n            }\n            // Escape special characters in CSS selector\n            const escapedName = name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n            // Find elements subscribed to this section\n            const subscribedElements = document.querySelectorAll(`[data-yield-subscribe-key*=\"${escapedName}\"]`);\n\n            subscribedElements.forEach(element => {\n                const subscribeKey = element.getAttribute('data-yield-subscribe-key');\n                const subscribeTarget = element.getAttribute('data-yield-subscribe-target');\n                const subscribeAttr = element.getAttribute('data-yield-subscribe-attr');\n\n                if (subscribeKey && subscribeKey.includes(name)) {\n                    const sectionContent = this._sections[name] || '';\n\n                    if (subscribeTarget === 'content' || subscribeTarget === 'children') {\n                        element.innerHTML = sectionContent;\n                    } else if (subscribeTarget === 'attr' || subscribeTarget === 'attribute') {\n                        if (subscribeAttr) {\n                            element.setAttribute(subscribeAttr, sectionContent);\n                        }\n                    } else {\n                        element.innerHTML = sectionContent;\n                    }\n                }\n            });\n\n            // Find elements with spa-yield-attr containing section name\n            const attrElements = document.querySelectorAll('[data-yield-attr]');\n            attrElements.forEach(element => {\n                const yieldAttr = element.getAttribute('data-yield-attr');\n\n                if (yieldAttr && yieldAttr.includes(name)) {\n                    const attrPairs = yieldAttr.split(',');\n\n                    attrPairs.forEach(pair => {\n                        let paths = pair.split(':');\n                        let attrName = paths.shift();\n                        let sectionName = paths.join(':');\n\n                        if (sectionName && sectionName.trim() === name) {\n                            const sectionContent = this._sections[name] || '';\n                            element.setAttribute(attrName.trim(), sectionContent);\n                        }\n                    });\n                }\n            });\n\n            // Find elements with app-yield-{name} attributes\n            if (name.split(':').length <= 1) {\n                const specialElements = document.querySelectorAll(`[data-yield-${escapedName}]`);\n                specialElements.forEach(element => {\n                    const sectionContent = this._sections[name] || '';\n                    element.innerHTML = sectionContent;\n                });\n\n            }\n\n            const contentElements = document.querySelectorAll(`[data-yield-content=\"${escapedName}\"]`);\n            contentElements.forEach(element => {\n                element.innerHTML = this._sections[name] || '';\n            });\n            const childrenElements = document.querySelectorAll(`[data-yield-children=\"${escapedName}\"]`);\n            childrenElements.forEach(element => {\n                element.innerHTML = this._sections[name] || '';\n            });\n        });\n\n        // Reset changed sections after processing\n        this.resetChangedSections();\n    };\n\n\n    loadServerData(data = {}) {\n\n    }\n\n\n\n    // ============================================================================\n    // STACK FUNCTIONS\n    // ============================================================================\n\n    // Initialize stacks storage\n\n\n    /**\n     * Push content to a stack\n     * @param {string} name - Stack name\n     * @param {string} content - Content to push\n     */\n    push(name, content) {\n        if (!this._stacks[name]) {\n            this._stacks[name] = [];\n        }\n        this._stacks[name].push(content);\n    };\n\n    /**\n     * Get stack content\n     * @param {string} name - Stack name\n     * @returns {string} Stack content\n     */\n    stack(name) {\n        return this._stacks[name] ? this._stacks[name].join('') : '';\n    };\n\n    // ============================================================================\n    // ONCE FUNCTIONS\n    // ============================================================================\n\n    // Initialize once storage\n\n    /**\n     * Execute content only once\n     * @param {string} content - Content to execute once\n     * @returns {string} Content if not executed before, empty string otherwise\n     */\n    once(content) {\n        const hash = this._hashContent(content);\n        if (!this._once[hash]) {\n            this._once[hash] = true;\n            return content;\n        }\n        return '';\n    };\n\n    /**\n     * Hash content for once tracking\n     * @param {string} content - Content to hash\n     * @returns {string} Hash string\n     */\n    _hashContent(content) {\n        let hash = 0;\n        if (content.length === 0) return hash.toString();\n\n        for (let i = 0; i < content.length; i++) {\n            const char = content.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n\n        return hash.toString();\n    };\n\n    // ============================================================================\n    // AUTH FUNCTIONS\n    // ============================================================================\n\n    /**\n     * Check if user is authenticated\n     * @param {string} guard - Guard name (optional)\n     * @returns {boolean} True if authenticated\n     */\n    isAuth(guard = null) {\n        // This should be implemented based on your auth system\n        // For now, return false as placeholder\n        return false;\n    };\n\n    /**\n     * Check if user has permission\n     * @param {string} permission - Permission name\n     * @param {*} model - Model instance (optional)\n     * @returns {boolean} True if user has permission\n     */\n    can(permission, model = null) {\n        // This should be implemented based on your permission system\n        // For now, return false as placeholder\n        return false;\n    };\n\n    // ============================================================================\n    // ERROR FUNCTIONS\n    // ============================================================================\n\n    /**\n     * Check if field has error\n     * @param {string} field - Field name\n     * @returns {boolean} True if field has error\n     */\n    hasError(field) {\n        // This should be implemented based on your error handling system\n        // For now, return false as placeholder\n        return false;\n    };\n\n    /**\n     * Get first error for field\n     * @param {string} field - Field name\n     * @returns {string} Error message\n     */\n    firstError(field) {\n        // This should be implemented based on your error handling system\n        // For now, return empty string as placeholder\n        return '';\n    };\n\n    // ============================================================================\n    // CSRF FUNCTIONS\n    // ============================================================================\n\n    /**\n     * Get CSRF token\n     * @returns {string} CSRF token\n     */\n    csrfToken() {\n        // This should be implemented based on your CSRF system\n        // For now, return empty string as placeholder\n        return '';\n    };\n\n    // ============================================================================\n    // LOOP FUNCTIONS\n    // ============================================================================\n\n    /**\n     * Foreach loop helper\n     * @param {Array|Object} items - Items to iterate\n     * @param {Function} callback - Callback function\n     * @returns {string} Rendered content\n     */\n    foreach(items, callback) {\n        if (!items) return '';\n\n        let result = '';\n\n        if (Array.isArray(items)) {\n            items.forEach((item, index) => {\n                result += callback(item, index);\n            });\n        } else if (typeof items === 'object') {\n            Object.entries(items).forEach(([key, value]) => {\n                result += callback(value, key);\n            });\n        }\n\n        return result;\n    };\n\n\n    /**\n  * Get route URL\n  * @param {string} name - Route name\n  * @param {object} params - Route parameters\n  * @returns {string} Route URL\n  */\n    route(name, params = {}) {\n        return this.App.Router.getURL(name, params);\n    }\n\n}\n"],"names":["SSRViewData","constructor","viewData","instances","indexMap","this","parseViewData","index","maxIndex","length","instancesMap","Map","keys","Object","forEach","key","set","get","next","prev","getById","id","scan","SSRViewDataCollection","views","setViews","name","getInstance","View","App","markupService","storageService","container","stateChangeListeners","currentMasterView","Engine","State","templates","_sections","_changedSections","_stacks","scanMode","_once","vitualContainer","document","createElement","setAttribute","style","display","VIEW_MOUNTED_QUEUE","CURRENT_SUPER_VIEW","CURRENT_SUPER_VIEW_PATH","CURRENT_SUPER_VIEW_MOUNTED","CURRENT_VIEW","CURRENT_VIEW_PATH","CURRENT_VIEW_MOUNTED","SUPER_VIEW_STACK","ALL_VIEW_STACK","PAGE_VIEW","renderTimes","cachedViews","serverRenderData","viewMap","cachedPageData","wrapperConfig","listeners","ssrData","ssrViewManager","cachedPageView","cachedTimes","SEO","tags","updateItem","value","items","item","element","querySelector","selector","tag","attrs","entries","head","appendChild","attribute","textContent","setApp","app","setContainer","init","data","_currentScope","getView","loadView","urlPath","clearOldRendering","message","hasCache","cacheKey","replace","cachedData","view","error","html","superView","isSuperView","needInsert","oldCacheData","path","result","superViewPath","ultraView","renderIndex","hasSuperView","unshift","renderView","setIsSuperView","console","render","scanView","route","__SSR_VIEW_ID__","viewId","$urlPath","__scan","scanRenderedView","isScanned","superViewData","nestedSuperViewData","virtualRender","log","mountAllViewsFromStack","then","catch","mountView","viewName","params","currentSuperView","unmounted","viewResult","body","setHTML","emitChangedSections","mounted","mountViewScan","scanResult","_isHydrated","mountContent","htmlContent","on","event","callback","push","off","filter","cb","emit","args","generateViewId","execute","fn","defaultValue","undefined","evaluate","escString","String","text","setSuperViewPath","addViewEngine","viewEngine","callViewEngineMounted","viewEngineId","mountAllViewsBottomUp","warn","Promise","resolve","checkInterval","setInterval","clearInterval","queue","i","beforeMount","superViews","includes","templateToDom","template","templator","innerHTML","content","firstChild","include","includeIf","exists","extendView","superViewName","registerSubscribe","attr","yieldKey","defaultContent","output","subscribeAttr","yieldContent","toLowerCase","KEYS","YIELD_CONTENT","YIELD_CHILDREN","YIELD_ATTR","join","renderOrScanView","variableData","mode","renderMethod","prerenderMethod","hasAwaitData","hasFetchData","updateVariableData","isPrerender","hasPrerender","API","getURIDAta","addToQueue","fetch","cache","reset","scope","viewWrapper","currentRenderTime","oldRenderTime","oldViews","Array","isArray","unmountView","cachedKeys","slice","clearOrphanedEventData","beforeUnmount","removeEvents","has","delete","destroy","resetView","values","section","type","oldContent","yield","renderSections","hasSection","getChangedSections","resetChangedSections","isChangedSection","escapedName","querySelectorAll","subscribeKey","getAttribute","subscribeTarget","sectionContent","yieldAttr","split","pair","paths","attrName","shift","sectionName","trim","loadServerData","stack","once","hash","_hashContent","toString","charCodeAt","isAuth","guard","can","permission","model","hasError","field","firstError","csrfToken","foreach","Router","getURL"],"sourceRoot":""}