{"version":3,"file":"core-5ab236cd.js","mappings":"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","sources":["webpack://App/./resources/js/app/core/services/StorageService.js","webpack://App/./resources/js/app/core/services/LoggerService.js","webpack://App/./resources/js/app/core/services/TemplateDetectorService.js","webpack://App/./resources/js/app/core/services/HttpService.js"],"sourcesContent":["import logger from \"./LoggerService.js\";\n\n// StorageService - Service thu·∫ßn t√∫y qu·∫£n l√Ω localStorage v·ªõi Event System, TTL v√† Encrypt\nexport class StorageService {\n    static instance = null;\n    static privateProperties = [\n        '__key', \n        '__isSupport', \n        '__data', \n        '__listeners', '__eventQueue', '__isUpdating', 'instance', \n        'set', 'get', 'remove', 'clear', 'getAll', 'has', 'getAllKeys', 'size', 'isEmpty', 'getInfo', 'debug', \n        'export', 'import', 'backup', 'restore', 'getStorageUsage', \n        'isStorageFull',\n        'setKey', 'getKey', 'support', '__loadData', '__updateData', 'emit', 'on', 'off', 'removeAllListeners', 'getEvents', 'getListenerCount',\n        'getTTLInfo', 'cleanExpired', 'enableEncryption', '__generateEncryptionKey',\n        '__encrypt', '__decrypt', '__isExpired', '__cleanExpiredData', '__createDynamicProperty', '__removeDynamicProperty'\n    ];\n    dynamicProperties = [];\n\n    constructor(key = 'onejs_storage') {\n        this.__key = key || \"onejs_storage\";\n        this.__isSupport = typeof (Storage) !== \"undefined\";\n        this.__data = {};\n        this.__listeners = new Map(); // Event listeners\n        this.__eventQueue = []; // Event queue for batching\n        this.__isUpdating = false;\n        \n        // Encryption system\n        this.encryptionKey = null;\n        this.useEncryption = false;\n        \n        if (this.__isSupport) {\n            this.__loadData();\n        }\n    }\n\n    // ==========================================\n    // PUBLIC STATIC METHODS\n    // ==========================================\n\n    /**\n     * Get the instance of the StorageService\n     * @param {string} key - The key to use for the storage\n     * @returns {StorageService} - The instance of the StorageService\n     */\n    static getInstance(key) {\n        if (!StorageService.instance) {\n            StorageService.instance = new StorageService(key);\n        }\n        return StorageService.instance;\n    }\n\n    // ==========================================\n    // PUBLIC INSTANCE METHODS - Configuration\n    // ==========================================\n\n    /**\n     * Set the key for the storage\n     * @param {string} key - The key to use for the storage\n     * @returns {StorageService} - The instance of the StorageService\n     */\n    setKey(key) {\n        if (typeof key !== 'string' || !key.trim()) {\n            throw new Error('Storage key must be a non-empty string');\n        }\n        \n        this.__key = key;\n        this.__loadData();\n        return this;\n    }\n\n    /**\n     * Get the current storage key\n     * @returns {string} - The current storage key\n     */\n    getKey() {\n        return this.__key;\n    }\n\n    /**\n     * Check if the storage is supported\n     * @returns {boolean} - True if the storage is supported, false otherwise\n     */\n    support() {\n        return this.__isSupport;\n    }\n\n    /**\n     * Enable/disable encryption\n     * @param {boolean} enable - Enable encryption\n     * @param {string} key - Encryption key (optional, will generate if not provided)\n     */\n    enableEncryption(enable = true, key = null) {\n        this.useEncryption = enable;\n        \n        if (enable && !key) {\n            // Generate a random encryption key\n            this.encryptionKey = this.__generateEncryptionKey();\n        } else if (enable && key) {\n            this.encryptionKey = key;\n        } else {\n            this.encryptionKey = null;\n        }\n        \n        logger.log(`üîß StorageService: Encryption ${enable ? 'enabled' : 'disabled'}`);\n    }\n\n    // ==========================================\n    // PUBLIC INSTANCE METHODS - Core Storage Operations\n    // ==========================================\n\n    /**\n     * Set the data in the storage with optional TTL\n     * @param {string|object} key - The key to use for the storage\n     * @param {any} value - The value to use for the storage\n     * @param {number|null} ttl - Time to live in seconds (null = no expiration)\n     * @returns {boolean} - True if the data is set, false otherwise\n     */\n    set(key, value, ttl = null) {\n        if (!this.__isSupport) return false;\n        \n        if (key === null || key === undefined) {\n            throw new Error('Key cannot be null or undefined');\n        }\n        \n        if (typeof key === 'object' && key !== null) {\n            // N·∫øu key l√† object, set nhi·ªÅu key-value\n            let success = true;\n            Object.keys(key).forEach(k => {\n                const v = key[k];\n                if (!this.set(k, v, ttl)) { success = false; }\n            })\n            return success;\n        }\n        \n        if (!(typeof key === 'string' || typeof key === 'number')) {\n            throw new Error('Key must be a string when setting single value');\n        }\n        \n        // Validate TTL\n        if (ttl && (typeof ttl !== 'number' || ttl <= 0)) {\n            throw new Error('TTL must be a positive number or null');\n        }\n        \n        const oldValue = this.__data[key];\n        \n        // Create data structure with TTL\n        const dataItem = {\n            value: value,\n            timestamp: Date.now()\n        };\n        \n        if (ttl !== null) {\n            dataItem.ttl = ttl * 1000;\n        }\n        \n        this.__data[key] = dataItem;\n        \n        try {\n            this.__updateData();\n            logger.log(`üíæ StorageService: Set ${key}:`, value, ttl ? `(TTL: ${ttl}ms)` : '(no TTL)');\n            \n            this.__createDynamicProperty(key, ttl);\n            // Emit events\n            this.emit(`set:${key}`, { key, value, oldValue, ttl });\n            this.emit('set', { key, value, oldValue, ttl });\n            \n            // Create dynamic property for direct access\n\n            return true;\n        } catch (error) {\n            // Revert on error\n            this.__data[key] = oldValue;\n            throw error;\n        }\n    }\n\n    /**\n     * Get the data from the storage with TTL check\n     * @param {string} key - The key to use for the storage\n     * @param {any} defaultValue - Default value if key not found or expired\n     * @returns {any} - The value of the data or null if expired\n     */\n    get(key, defaultValue = null) {\n        if (!this.__isSupport) return defaultValue;\n        \n        if (typeof key !== 'string') {\n            throw new Error('Key must be a string');\n        }\n        \n        if (typeof this.__data[key] === 'undefined') return defaultValue;\n        \n        const dataItem = this.__data[key];\n        \n        // Check if data has TTL structure\n        if (dataItem && typeof dataItem === 'object' && 'value' in dataItem) {\n            // Check if expired\n            if (this.__isExpired(dataItem)) {\n                logger.log(`‚è∞ StorageService: Key ${key} has expired, removing...`);\n                this.remove(key);\n                return defaultValue;\n            }\n            \n            logger.log(`üìñ StorageService: Retrieved ${key}:`, dataItem.value);\n            return dataItem.value;\n        } else {\n            // Legacy data without TTL structure\n            logger.log(`üìñ StorageService: Retrieved ${key}:`, dataItem);\n            return dataItem;\n        }\n    }\n\n    /**\n     * Remove the data from the storage\n     * @param {string} key - The key to use for the storage\n     * @returns {boolean} - True if the data is removed, false otherwise\n     */\n    remove(key) {\n        if (!this.__isSupport) return false;\n        \n        if (typeof key !== 'string') {\n            throw new Error('Key must be a string');\n        }\n        \n        if (Object.keys(this.__data).length === 0 || typeof this.__data[key] === 'undefined') {\n            return false;\n        }\n        \n        const oldValue = this.__data[key];\n        delete this.__data[key];\n        \n        try {\n            this.__updateData();\n            logger.log('üóëÔ∏è StorageService: Removed', key);\n            \n            // Emit events\n            this.emit('remove', { key, oldValue });\n            this.emit(`remove:${key}`, { key, oldValue });\n            \n            // Remove dynamic property\n            this.__removeDynamicProperty(key);\n            \n            return true;\n        } catch (error) {\n            // Revert on error\n            this.__data[key] = oldValue;\n            throw error;\n        }\n    }\n\n    /**\n     * Clear the data from the storage\n     */\n    clear() {\n        const oldData = { ...this.__data };\n        this.__data = {};\n\n        // Remove all dynamic properties\n        if (this.dynamicProperties) {\n            for (const key of this.dynamicProperties) {\n                this.__removeDynamicProperty(key);\n            }\n            this.dynamicProperties = [];\n        }\n        \n        try {\n            this.__updateData();\n            logger.log('üßπ StorageService: Cleared all data');\n            \n            // Emit events\n            this.emit('clear', { oldData });\n        } catch (error) {\n            // Revert on error\n            this.__data = oldData;\n            throw error;\n        }\n    }\n\n    /**\n     * Get all data from the storage (excluding expired items)\n     * @returns {object} - All valid data in storage\n     */\n    getAll() {\n        // Clean expired data first\n        this.__cleanExpiredData();\n        \n        const result = {};\n        for (const [key, dataItem] of Object.entries(this.__data)) {\n            if (dataItem && typeof dataItem === 'object' && 'value' in dataItem) {\n                result[key] = dataItem.value;\n            } else {\n                result[key] = dataItem; // Legacy data\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Check if key exists and is not expired\n     * @param {string} key - The key to check\n     * @returns {boolean} - True if key exists and not expired, false otherwise\n     */\n    has(key) {\n        if (typeof key !== 'string') {\n            throw new Error('Key must be a string');\n        }\n        \n        if (typeof this.__data[key] === 'undefined') return false;\n        \n        const dataItem = this.__data[key];\n        \n        // Check if data has TTL structure\n        if (dataItem && typeof dataItem === 'object' && 'value' in dataItem) {\n            return !this.__isExpired(dataItem);\n        }\n        \n        return true; // Legacy data without TTL\n    }\n\n    /**\n     * Get all keys (excluding expired items)\n     * @returns {string[]} - Array of all valid keys\n     */\n    getAllKeys() {\n        // Clean expired data first\n        this.__cleanExpiredData();\n        \n        return Object.keys(this.__data);\n    }\n\n    /**\n     * Get storage size (number of valid keys)\n     * @returns {number} - Number of valid keys in storage\n     */\n    size() {\n        // Clean expired data first\n        this.__cleanExpiredData();\n        \n        return Object.keys(this.__data).length;\n    }\n\n    /**\n     * Check if storage is empty\n     * @returns {boolean} - True if storage is empty, false otherwise\n     */\n    isEmpty() {\n        return this.size() === 0;\n    }\n\n    /**\n     * Get storage info\n     * @returns {object} - Storage information\n     */\n    getInfo() {\n        // Clean expired data first\n        const expiredRemoved = this.__cleanExpiredData();\n        \n        return {\n            key: this.__key,\n            isSupport: this.__isSupport,\n            size: this.size(),\n            keys: this.getAllKeys(),\n            isEmpty: this.isEmpty(),\n            events: this.getEvents(),\n            totalListeners: Array.from(this.__listeners.values()).reduce((sum, listeners) => sum + listeners.length, 0),\n            isUpdating: this.__isUpdating,\n            useEncryption: this.useEncryption,\n            hasEncryptionKey: !!this.encryptionKey,\n            expiredRemoved: expiredRemoved,\n            dynamicProperties: this.dynamicProperties ? this.dynamicProperties.length : 0\n        };\n    }\n\n    /**\n     * Debug storage\n     */\n    debug() {\n        logger.log('üîç StorageService Debug:', this.getInfo());\n        \n        // Show TTL info for each key\n        logger.log('üìã TTL Information:');\n        for (const [key, dataItem] of Object.entries(this.__data)) {\n            if (dataItem && typeof dataItem === 'object' && 'value' in dataItem) {\n                const isExpired = this.__isExpired(dataItem);\n                const ttl = dataItem.ttl;\n                const remaining = dataItem.ttl ? Math.max(0, (dataItem.timestamp + dataItem.ttl) - Date.now()) : null;\n                logger.log(`  ${key}: ${isExpired ? 'EXPIRED' : 'VALID'}${dataItem.ttl ? ` (TTL: ${dataItem.ttl}ms, Remaining: ${remaining}ms)` : ' (no TTL)'}`);\n            } else {\n                logger.log(`  ${key}: LEGACY (no TTL)`);\n            }\n        }\n        \n        // Show dynamic properties\n        logger.log('üîß Dynamic Properties:', this.dynamicProperties || []);\n    }\n\n    // ==========================================\n    // PUBLIC INSTANCE METHODS - TTL Operations\n    // ==========================================\n\n    /**\n     * Get TTL information for a key\n     * @param {string} key - The key to check\n     * @returns {object|null} - TTL information or null if not found\n     */\n    getTTLInfo(key) {\n        if (typeof key !== 'string') {\n            throw new Error('Key must be a string');\n        }\n        \n        if (typeof this.__data[key] === 'undefined') return null;\n        \n        const dataItem = this.__data[key];\n        \n        if (dataItem && typeof dataItem === 'object' && 'value' in dataItem) {\n            const isExpired = this.__isExpired(dataItem);\n            const remaining = dataItem.ttl ? Math.max(0, (dataItem.timestamp + dataItem.ttl) - Date.now()) : null;\n            \n            return {\n                hasTTL: !!dataItem.ttl,\n                ttl: dataItem.ttl,\n                timestamp: dataItem.timestamp,\n                isExpired,\n                remaining,\n                expiryTime: dataItem.ttl ? dataItem.timestamp + dataItem.ttl : null\n            };\n        }\n        \n        return null; // Legacy data without TTL\n    }\n\n    /**\n     * Clean all expired data\n     * @returns {number} - Number of expired items removed\n     */\n    cleanExpired() {\n        return this.__cleanExpiredData();\n    }\n\n    // ==========================================\n    // PUBLIC INSTANCE METHODS - Import/Export\n    // ==========================================\n\n    /**\n     * Export data to JSON string\n     * @returns {string} - JSON string of all data\n     */\n    export() {\n        return JSON.stringify(this.getAll(), null, 2);\n    }\n\n    /**\n     * Import data from JSON string\n     * @param {string} jsonString - JSON string to import\n     * @returns {boolean} - True if import successful, false otherwise\n     */\n    import(jsonString) {\n        if (typeof jsonString !== 'string') {\n            throw new Error('JSON string must be a string');\n        }\n        \n        try {\n            const data = JSON.parse(jsonString);\n            const oldData = { ...this.__data };\n            \n            // Convert imported data to TTL structure\n            this.__data = {};\n            for (const [key, value] of Object.entries(data)) {\n                this.__data[key] = {\n                    value: value,\n                    timestamp: Date.now()\n                };\n            }\n            \n            this.__updateData();\n            \n            logger.log('üì• StorageService: Imported data successfully');\n            \n            // Emit events\n            this.emit('import', { oldData, newData: data });\n            \n            return true;\n        } catch (error) {\n            logger.error('‚ùå StorageService: Failed to import data:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Backup current data\n     * @returns {object} - Backup data with timestamp\n     */\n    backup() {\n        return {\n            timestamp: Date.now(),\n            key: this.__key,\n            data: { ...this.__data } // Return copy\n        };\n    }\n\n    /**\n     * Restore from backup\n     * @param {object} backup - Backup data\n     * @returns {boolean} - True if restore successful, false otherwise\n     */\n    restore(backup) {\n        if (!backup || typeof backup !== 'object') {\n            throw new Error('Backup must be a valid object');\n        }\n        \n        if (!backup.data) {\n            logger.error('‚ùå StorageService: Invalid backup data');\n            return false;\n        }\n\n        const oldData = { ...this.__data };\n        this.__data = { ...backup.data }; // Use copy\n        \n        try {\n            this.__updateData();\n            logger.log('üì§ StorageService: Restored from backup:', backup.timestamp);\n            \n            // Emit events\n            this.emit('restore', { oldData, newData: backup.data, backup });\n            \n            return true;\n        } catch (error) {\n            // Revert on error\n            this.__data = oldData;\n            throw error;\n        }\n    }\n\n    // ==========================================\n    // PUBLIC INSTANCE METHODS - Storage Utilities\n    // ==========================================\n\n    /**\n     * Get storage usage in bytes\n     * @returns {number} - Storage usage in bytes\n     */\n    getStorageUsage() {\n        if (!this.__isSupport) return 0;\n        \n        try {\n            const data = localStorage.getItem(this.__key);\n            return data ? new Blob([data]).size : 0;\n        } catch (error) {\n            logger.error('‚ùå StorageService: Failed to get storage usage:', error);\n            return 0;\n        }\n    }\n\n    /**\n     * Check if storage is full\n     * @returns {boolean} - True if storage is full, false otherwise\n     */\n    isStorageFull() {\n        try {\n            const testKey = '__storage_test__';\n            const testValue = 'x'.repeat(1024); // 1KB test\n            \n            localStorage.setItem(testKey, testValue);\n            localStorage.removeItem(testKey);\n            return false;\n        } catch (error) {\n            return true; // Storage is full\n        }\n    }\n\n    // ==========================================\n    // PUBLIC INSTANCE METHODS - Event System\n    // ==========================================\n\n    /**\n     * Add event listener\n     * @param {string} event - Event name\n     * @param {function} callback - Callback function\n     * @returns {function} - Unsubscribe function\n     */\n    on(event, callback) {\n        if (typeof event !== 'string' || !event.trim()) {\n            throw new Error('Event name must be a non-empty string');\n        }\n        \n        if (typeof callback !== 'function') {\n            throw new Error('Callback must be a function');\n        }\n        \n        if (!this.__listeners.has(event)) {\n            this.__listeners.set(event, []);\n        }\n        \n        this.__listeners.get(event).push(callback);\n        logger.log(`üéß StorageService: Added listener for event: ${event}`);\n        \n        // Return unsubscribe function\n        return () => this.off(event, callback);\n    }\n\n    /**\n     * Remove event listener\n     * @param {string} event - Event name\n     * @param {function} callback - Callback function\n     */\n    off(event, callback) {\n        if (!this.__listeners.has(event)) return;\n        \n        const listeners = this.__listeners.get(event);\n        const index = listeners.indexOf(callback);\n        if (index > -1) {\n            listeners.splice(index, 1);\n            logger.log(`üéß StorageService: Removed listener for event: ${event}`);\n        }\n    }\n\n    /**\n     * Remove all listeners for an event\n     * @param {string} event - Event name\n     */\n    removeAllListeners(event) {\n        if (event) {\n            this.__listeners.delete(event);\n            logger.log(`üéß StorageService: Removed all listeners for event: ${event}`);\n        } else {\n            this.__listeners.clear();\n            logger.log('üéß StorageService: Removed all listeners');\n        }\n    }\n\n    /**\n     * Get all registered events\n     * @returns {string[]} - Array of event names\n     */\n    getEvents() {\n        return Array.from(this.__listeners.keys());\n    }\n\n    /**\n     * Get listener count for an event\n     * @param {string} event - Event name\n     * @returns {number} - Number of listeners\n     */\n    getListenerCount(event) {\n        return this.__listeners.has(event) ? this.__listeners.get(event).length : 0;\n    }\n\n    // ==========================================\n    // PRIVATE METHODS\n    // ==========================================\n\n    /**\n     * Generate encryption key\n     * @returns {string} - Generated encryption key\n     */\n    __generateEncryptionKey() {\n        const array = new Uint8Array(32);\n        crypto.getRandomValues(array);\n        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n    }\n\n    /**\n     * Encrypt data\n     * @param {string} data - Data to encrypt\n     * @returns {string} - Encrypted data\n     */\n    __encrypt(data) {\n        if (!this.useEncryption || !this.encryptionKey) {\n            return data;\n        }\n        \n        try {\n            // Simple XOR encryption (for development purposes)\n            // In production, use proper encryption like AES\n            let encrypted = '';\n            for (let i = 0; i < data.length; i++) {\n                const charCode = data.charCodeAt(i) ^ this.encryptionKey.charCodeAt(i % this.encryptionKey.length);\n                encrypted += String.fromCharCode(charCode);\n            }\n            return btoa(encrypted); // Base64 encode\n        } catch (error) {\n            console.error('‚ùå StorageService: Encryption failed:', error);\n            return data;\n        }\n    }\n\n    /**\n     * Decrypt data\n     * @param {string} data - Data to decrypt\n     * @returns {string} - Decrypted data\n     */\n    __decrypt(data) {\n        if (!this.useEncryption || !this.encryptionKey) {\n            return data;\n        }\n        \n        try {\n            // Simple XOR decryption (for development purposes)\n            const decoded = atob(data); // Base64 decode\n            let decrypted = '';\n            for (let i = 0; i < decoded.length; i++) {\n                const charCode = decoded.charCodeAt(i) ^ this.encryptionKey.charCodeAt(i % this.encryptionKey.length);\n                decrypted += String.fromCharCode(charCode);\n            }\n            return decrypted;\n        } catch (error) {\n            console.error('‚ùå StorageService: Decryption failed:', error);\n            return data;\n        }\n    }\n\n    /**\n     * Check if data is expired\n     * @param {object} dataItem - Data item with timestamp and ttl\n     * @returns {boolean} - True if expired, false otherwise\n     */\n    __isExpired(dataItem) {\n        if (!dataItem || !dataItem.timestamp || !dataItem.ttl) {\n            return false; // No TTL, not expired\n        }\n        \n        const now = Date.now();\n        const expiryTime = dataItem.timestamp + dataItem.ttl;\n        return now > expiryTime;\n    }\n\n    /**\n     * Clean expired data\n     * @returns {number} - Number of expired items removed\n     */\n    __cleanExpiredData() {\n        let removed = 0;\n        const keysToRemove = [];\n        \n        for (const [key, dataItem] of Object.entries(this.__data)) {\n            if (this.__isExpired(dataItem)) {\n                keysToRemove.push(key);\n            }\n        }\n        \n        for (const key of keysToRemove) {\n            delete this.__data[key];\n            removed++;\n            logger.log(`üóëÔ∏è StorageService: Removed expired key: ${key}`);\n        }\n        \n        if (removed > 0) {\n            this.__updateData();\n        }\n        \n        return removed;\n    }\n\n    /**\n     * Load the data from the storage (private method)\n     */\n    __loadData() {\n        if (!this.__isSupport) return;\n        \n        try {\n            const data = localStorage.getItem(this.__key);\n            if (data) {\n                const decryptedData = this.__decrypt(data);\n                this.__data = JSON.parse(decryptedData);\n                \n                // Clean expired data on load\n                this.__cleanExpiredData();\n            }\n        } catch (error) {\n            console.error('‚ùå StorageService: Failed to load data:', error);\n            this.__data = {};\n        }\n    }\n\n    /**\n     * Update the data in the storage (private method)\n     */\n    __updateData() {\n        if (!this.__isSupport || this.__isUpdating) return;\n        \n        this.__isUpdating = true;\n        \n        try {\n            const jsonData = JSON.stringify(this.__data);\n            const encryptedData = this.__encrypt(jsonData);\n            localStorage.setItem(this.__key, encryptedData);\n            logger.log('üíæ StorageService: Updated data for key:', this.__key);\n        } catch (error) {\n            logger.error('‚ùå StorageService: Failed to update data:', error);\n            throw error;\n        } finally {\n            this.__isUpdating = false;\n        }\n    }\n\n    /**\n     * Emit event to all listeners (private method)\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     */\n    emit(event, data) {\n        if (!this.__listeners.has(event)) return;\n        \n        const listeners = this.__listeners.get(event);\n        listeners.forEach(callback => {\n            try {\n                callback(data);\n            } catch (error) {\n                console.error(`‚ùå StorageService: Error in event listener for ${event}:`, error);\n            }\n        });\n    }\n\n    /**\n     * Create dynamic property for direct access\n     * @param {string} key - The key\n     * @param {number|null} ttl - TTL value\n     */\n    __createDynamicProperty(key, ttl) {\n        try {\n            if (!StorageService.privateProperties.includes(key) && !this.dynamicProperties.includes(key)) {\n                this.dynamicProperties.push(key);\n                Object.defineProperty(this, key, {\n                    set: (value) => this.set(key, value, ttl),\n                    get: () => this.get(key),\n                    configurable: true\n                });\n            }\n        } catch (error) {\n            logger.error('‚ùå StorageService: Failed to create dynamic property:', error);\n        }\n    }\n\n    /**\n     * Remove dynamic property\n     * @param {string} key - The key to remove\n     */\n    __removeDynamicProperty(key) {\n        try {\n            if (this.dynamicProperties && this.dynamicProperties.includes(key)) {\n                delete this[key];\n                this.dynamicProperties = this.dynamicProperties.filter(k => k !== key);\n            }\n        } catch (error) {\n            logger.error('‚ùå StorageService: Failed to remove dynamic property:', error);\n        }\n    }\n}\n\n// Export singleton instance\nconst storage = StorageService.getInstance('onejs_storage');\nexport default storage;","export class LoggerService {\n    constructor(config) {\n        this.config = {\n            level: 'info',\n            enabled: false,\n            console: true,\n            remote: false\n        };\n        \n        if (config) {\n            this.setConfig(config);\n        }\n\n        this.logs = [];\n    }\n\n    setConfig(config) {\n        this.config = { ...this.config, ...config };\n    }\n\n    getConfig() {\n        return this.config;\n    }\n\n    consoleLog(method, ...args) {\n        this.logs.push(...args)\n        if (this.config.console && this.config.enabled) {\n            return console[method].apply(console, args);\n        }\n    }\n\n    log(...args) {\n        return this.consoleLog('log', ...args);\n    }\n\n    warn(...args) {\n        return this.consoleLog('warn', ...args);\n    }\n\n    error(...args) {\n        return this.consoleLog('error', ...args); \n    }\n\n    info(...args) {\n        return this.consoleLog('info', ...args);\n    }\n\n    debug(...args) {\n        return this.consoleLog('debug', ...args);\n    }\n\n}\n\n\nexport const logger = new LoggerService({level: 'info', enabled: true, console: true, remote: false});\nexport default logger;\n\n","/**\n * Class qu·∫£n l√Ω vi·ªác parse v√† t√¨m ki·∫øm c√°c c·∫∑p comment tags\n * H·ªó tr·ª£ t√¨m ki·∫øm theo pattern v·ªõi wildcard (*)\n * \n * @example\n * const parser = new TemplateDetectorService(document.body);\n * const pairs = parser.find('one-template:*');\n * parser.display(pairs);\n */\nexport class TemplateDetectorService {\n    /**\n     * Kh·ªüi t·∫°o parser v·ªõi element g·ªëc\n     * @param {Element} rootElement - Element g·ªëc ƒë·ªÉ t√¨m ki·∫øm (m·∫∑c ƒë·ªãnh: document.body)\n     */\n    constructor(rootElement = document.body) {\n        this.rootElement = rootElement;\n        this.cachedComments = null;\n    }\n\n    /**\n     * ƒê·∫∑t element g·ªëc m·ªõi\n     * @param {Element} element - Element g·ªëc m·ªõi\n     */\n    setRootElement(element) {\n        this.rootElement = element;\n        this.cachedComments = null;\n        return this;\n    }\n\n    /**\n     * L·∫•y t·∫•t c·∫£ comment nodes t·ª´ rootElement\n     * @param {boolean} useCache - S·ª≠ d·ª•ng cache hay kh√¥ng\n     * @returns {Array<Comment>}\n     */\n    getAllComments(useCache = true) {\n        if (useCache && this.cachedComments) {\n            return this.cachedComments;\n        }\n\n        const comments = [];\n        const walker = document.createTreeWalker(\n            this.rootElement,\n            NodeFilter.SHOW_COMMENT,\n            null,\n            false\n        );\n\n        let node;\n        while (node = walker.nextNode()) {\n            comments.push(node);\n        }\n\n        if (useCache) {\n            this.cachedComments = comments;\n        }\n\n        return comments;\n    }\n\n    /**\n     * Parse m·ªôt comment node ƒë·ªÉ l·∫•y th√¥ng tin\n     * @param {Comment} commentNode - Comment node c·∫ßn parse\n     * @returns {Object|null} - Th√¥ng tin tag ho·∫∑c null n·∫øu kh√¥ng ph·∫£i tag h·ª£p l·ªá\n     */\n    parseComment(commentNode) {\n        const text = commentNode.nodeValue.trim();\n\n        // Pattern t·ªïng qu√°t: [prefix:name] ho·∫∑c [prefix]\n        // Ki·ªÉm tra tag m·ªü: <!-- [prefix:name attribute=\"...\"] -->\n        const openMatch = text.match(/^\\[([^\\/\\]]+?)(?:\\s+(.+))?\\]$/);\n        if (openMatch) {\n            const fullName = openMatch[1];\n            const attributes = {};\n\n            if (openMatch[2]) {\n                // Parse c√°c attributes nh∆∞ subscribe=\"userState,items\"\n                const attrMatch = openMatch[2].match(/(\\w+)=\"([^\"]+)\"/g);\n                if (attrMatch) {\n                    attrMatch.forEach(attr => {\n                        const [key, value] = attr.split('=');\n                        attributes[key] = value.replace(/\"/g, '');\n                    });\n                }\n            }\n\n            return {\n                type: 'open',\n                fullName: fullName,\n                attributes: attributes,\n                node: commentNode\n            };\n        }\n\n        // Ki·ªÉm tra tag ƒë√≥ng: <!-- [/prefix:name] -->\n        const closeMatch = text.match(/^\\[\\/([^\\/\\]]+?)\\]$/);\n        if (closeMatch) {\n            return {\n                type: 'close',\n                fullName: closeMatch[1],\n                node: commentNode\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * L·∫•y t·∫•t c·∫£ c√°c siblings gi·ªØa hai node (c√πng parent)\n     * @param {Node} startNode - Node b·∫Øt ƒë·∫ßu\n     * @param {Node} endNode - Node k·∫øt th√∫c\n     * @returns {Array<Node>|null} - M·∫£ng nodes ho·∫∑c null n·∫øu kh√¥ng c√πng parent\n     */\n    getNodesBetween(startNode, endNode) {\n        // Ki·ªÉm tra xem c√≥ c√πng parent kh√¥ng\n        if (startNode.parentNode !== endNode.parentNode) {\n            return null;\n        }\n\n        const nodes = [];\n        let current = startNode.nextSibling;\n\n        while (current && current !== endNode) {\n            nodes.push(current);\n            current = current.nextSibling;\n        }\n\n        return nodes;\n    }\n\n    /**\n     * Chuy·ªÉn ƒë·ªïi pattern th√†nh regex\n     * @param {string} pattern - Pattern v·ªõi wildcard (*)\n     * @returns {RegExp}\n     * \n     * @example\n     * patternToRegex('*:*')              // Match t·∫•t c·∫£\n     * patternToRegex('one-*')            // Match \"one-template\", \"one-component\"\n     * patternToRegex('one-template:*')   // Match \"one-template:profile\", etc.\n     */\n    patternToRegex(pattern) {\n        if (!pattern || pattern === '*' || pattern === '*:*') {\n            return /.*/;\n        }\n\n        // Escape c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát trong regex (tr·ª´ *)\n        let regexStr = pattern\n            .replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&')  // Escape regex special chars\n            .replace(/\\*/g, '.*');                    // Convert * th√†nh .*\n\n        // Th√™m ^ v√† $ ƒë·ªÉ match ch√≠nh x√°c to√†n b·ªô string\n        regexStr = '^' + regexStr + '$';\n\n        return new RegExp(regexStr);\n    }\n\n    /**\n     * Ki·ªÉm tra xem m·ªôt t√™n c√≥ kh·ªõp v·ªõi pattern kh√¥ng\n     * @param {string} fullName - T√™n ƒë·∫ßy ƒë·ªß c·ªßa tag\n     * @param {string} pattern - Pattern ƒë·ªÉ so kh·ªõp\n     * @returns {boolean}\n     */\n    matchPattern(fullName, pattern) {\n        const regex = this.patternToRegex(pattern);\n        return regex.test(fullName);\n    }\n\n    /**\n     * T√¨m t·∫•t c·∫£ c√°c c·∫∑p tags theo pattern\n     * @param {string} pattern - Pattern ƒë·ªÉ l·ªçc (m·∫∑c ƒë·ªãnh: '*:*')\n     * @param {Object} options - T√πy ch·ªçn b·ªï sung\n     * @param {boolean} options.useCache - S·ª≠ d·ª•ng cache comments\n     * @returns {Array<Object>} - M·∫£ng c√°c c·∫∑p tags t√¨m ƒë∆∞·ª£c\n     * \n     * @example\n     * parser.find('*:*')                   // T√¨m t·∫•t c·∫£\n     * parser.find('one-template:*')        // Ch·ªâ t√¨m one-template\n     * parser.find('one-template:profile')  // T√¨m ch√≠nh x√°c profile\n     */\n    find(pattern = '*:*', options = {}) {\n        const { useCache = true } = options;\n\n        const comments = this.getAllComments(useCache);\n        const parsed = comments.map(c => this.parseComment(c)).filter(p => p !== null);\n\n        const pairs = [];\n        const stack = [];\n\n        for (let i = 0; i < parsed.length; i++) {\n            const current = parsed[i];\n\n            // Ki·ªÉm tra xem c√≥ kh·ªõp v·ªõi pattern kh√¥ng\n            if (!this.matchPattern(current.fullName, pattern)) {\n                continue;\n            }\n\n            if (current.type === 'open') {\n                // ƒê·∫©y tag m·ªü v√†o stack\n                stack.push({\n                    ...current,\n                    index: i\n                });\n            } else if (current.type === 'close') {\n                // T√¨m tag m·ªü t∆∞∆°ng ·ª©ng t·ª´ stack\n                let foundIndex = -1;\n                for (let j = stack.length - 1; j >= 0; j--) {\n                    if (stack[j].fullName === current.fullName) {\n                        foundIndex = j;\n                        break;\n                    }\n                }\n\n                if (foundIndex !== -1) {\n                    const openTag = stack[foundIndex];\n\n                    // L·∫•y c√°c nodes n·∫±m gi·ªØa\n                    const nodesBetween = this.getNodesBetween(openTag.node, current.node);\n\n                    // Ch·ªâ th√™m v√†o n·∫øu c√πng parent\n                    if (nodesBetween !== null) {\n                        pairs.push({\n                            fullName: current.fullName,\n                            openTag: openTag.node,\n                            closeTag: current.node,\n                            attributes: openTag.attributes,\n                            nodes: nodesBetween,\n                            parent: openTag.node.parentNode\n                        });\n                    }\n\n                    // X√≥a kh·ªèi stack\n                    stack.splice(foundIndex, 1);\n                }\n            }\n        }\n\n        return pairs;\n    }\n\n    /**\n     * T√¨m m·ªôt c·∫∑p tag duy nh·∫•t theo pattern\n     * @param {string} pattern - Pattern ƒë·ªÉ t√¨m\n     * @returns {Object|null} - C·∫∑p tag t√¨m ƒë∆∞·ª£c ho·∫∑c null\n     */\n    findOne(pattern) {\n        const pairs = this.find(pattern);\n        return pairs.length > 0 ? pairs[0] : null;\n    }\n\n    /**\n     * L·ªçc c√°c c·∫∑p tags theo ƒëi·ªÅu ki·ªán t√πy ch·ªânh\n     * @param {Function} filterFn - H√†m filter (pair) => boolean\n     * @param {string} pattern - Pattern ban ƒë·∫ßu\n     * @returns {Array<Object>}\n     */\n    filter(filterFn, pattern = '*:*') {\n        const pairs = this.find(pattern);\n        return pairs.filter(filterFn);\n    }\n\n    /**\n     * ƒê·∫øm s·ªë l∆∞·ª£ng c·∫∑p tags theo pattern\n     * @param {string} pattern - Pattern ƒë·ªÉ ƒë·∫øm\n     * @returns {number}\n     */\n    count(pattern = '*:*') {\n        return this.find(pattern).length;\n    }\n\n    /**\n     * L·∫•y danh s√°ch t·∫•t c·∫£ c√°c t√™n tags duy nh·∫•t\n     * @param {string} pattern - Pattern ƒë·ªÉ l·ªçc\n     * @returns {Array<string>}\n     */\n    getUniqueNames(pattern = '*:*') {\n        const pairs = this.find(pattern);\n        return [...new Set(pairs.map(p => p.fullName))];\n    }\n\n    /**\n     * Hi·ªÉn th·ªã k·∫øt qu·∫£ t√¨m ki·∫øm trong console\n     * @param {Array<Object>|string} pairsOrPattern - M·∫£ng pairs ho·∫∑c pattern string\n     * @param {Object} options - T√πy ch·ªçn hi·ªÉn th·ªã\n     */\n    display(pairsOrPattern, options = {}) {\n        const {\n            showAttributes = true,\n            showParent = true,\n            showNodes = true,\n            maxNodePreview = 3\n        } = options;\n\n        let pairs, patternInfo = '';\n\n        // N·∫øu truy·ªÅn v√†o l√† string, t√¨m ki·∫øm tr∆∞·ªõc\n        if (typeof pairsOrPattern === 'string') {\n            patternInfo = ` v·ªõi pattern \"${pairsOrPattern}\"`;\n            pairs = this.find(pairsOrPattern);\n        } else {\n            pairs = pairsOrPattern;\n        }\n\n        console.log(`\\n${'='.repeat(80)}`);\n        console.log(`T√¨m th·∫•y ${pairs.length} c·∫∑p tags${patternInfo}`);\n        console.log(`${'='.repeat(80)}\\n`);\n\n        if (pairs.length === 0) {\n            console.log('‚ùå Kh√¥ng t√¨m th·∫•y c·∫∑p tags n√†o!');\n            return;\n        }\n\n        pairs.forEach((pair, index) => {\n            console.log(`\\nüì¶ C·∫∑p ${index + 1}: [${pair.fullName}]`);\n            console.log('-'.repeat(60));\n\n            if (showAttributes) {\n                console.log('üìã Attributes:',\n                    Object.keys(pair.attributes).length > 0\n                        ? pair.attributes\n                        : '(kh√¥ng c√≥)'\n                );\n            }\n\n            if (showParent) {\n                console.log('üîº Parent:', pair.parent.tagName.toLowerCase(),\n                    pair.parent.className ? `class=\"${pair.parent.className}\"` : ''\n                );\n            }\n\n            if (showNodes) {\n                console.log(`üìÑ N·ªôi dung (${pair.nodes.length} nodes):`);\n\n                const previewNodes = pair.nodes.slice(0, maxNodePreview);\n                previewNodes.forEach(node => {\n                    if (node.nodeType === Node.ELEMENT_NODE) {\n                        const className = node.className ? ` class=\"${node.className}\"` : '';\n                        console.log(`   ‚îú‚îÄ <${node.tagName.toLowerCase()}${className}>`);\n                    } else if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim()) {\n                        const text = node.nodeValue.trim().substring(0, 50);\n                        console.log(`   ‚îú‚îÄ Text: \"${text}${text.length >= 50 ? '...' : ''}\"`);\n                    }\n                });\n\n                if (pair.nodes.length > maxNodePreview) {\n                    console.log(`   ‚îî‚îÄ ... v√† ${pair.nodes.length - maxNodePreview} nodes kh√°c`);\n                }\n            }\n        });\n\n        console.log(`\\n${'='.repeat(80)}\\n`);\n    }\n\n    /**\n     * X√≥a cache ƒë·ªÉ bu·ªôc parse l·∫°i\n     */\n    clearCache() {\n        this.cachedComments = null;\n        return this;\n    }\n}","/**\n * HTTP Service Module\n * ES6 Module for Blade Compiler\n */\n\n\nclass HttpService {\n\n    constructor() {\n        this.baseUrl = '';\n        this.timeout = 10000;\n        this.defaultHeaders = {};\n    }\n\n    setBaseUrl(url) {\n        this.baseUrl = url;\n    }\n\n    setTimeout(timeout) {\n        this.timeout = timeout;\n    }\n\n    setDefaultHeaders(headers) {\n        this.defaultHeaders = { ...this.defaultHeaders, ...headers };\n    }\n\n    setHeader(name, value) {\n        this.defaultHeaders[name] = value;\n    }\n\n    async request(method, url, data = null, options = {}) {\n        const fullUrl = url.startsWith('http') ? url : this.baseUrl + url;\n        \n        const config = {\n            method: method.toUpperCase(),\n            headers: {\n                ...this.defaultHeaders,\n                ...options.headers\n            },\n            ...options\n        };\n\n        if (data && (method.toUpperCase() === 'POST' || method.toUpperCase() === 'PUT' || method.toUpperCase() === 'PATCH')) {\n            if (config.headers['Content-Type'] === 'application/json') {\n                config.body = JSON.stringify(data);\n            } else {\n                config.body = data;\n            }\n        }\n\n        try {\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n            \n            const response = await fetch(fullUrl, {\n                ...config,\n                signal: controller.signal\n            });\n            \n            clearTimeout(timeoutId);\n\n            const responseData = await response.json().catch(() => ({}));\n            \n            return {\n                status: response.ok,\n                statusCode: response.status,\n                data: responseData,\n                headers: response.headers\n            };\n        } catch (error) {\n            if (error.name === 'AbortError') {\n                throw new Error('Request timeout');\n            }\n            throw error;\n        }\n    }\n\n    async get(url, options = {}) {\n        return this.request('GET', url, null, options);\n    }\n\n    async post(url, data = null, options = {}) {\n        return this.request('POST', url, data, options);\n    }\n\n    async put(url, data = null, options = {}) {\n        return this.request('PUT', url, data, options);\n    }\n\n    async patch(url, data = null, options = {}) {\n        return this.request('PATCH', url, data, options);\n    }\n\n    async delete(url, options = {}) {\n        return this.request('DELETE', url, null, options);\n    }\n}\n\n\n// Export for ES6 modules\nexport { HttpService };"],"names":["StorageService","static","dynamicProperties","constructor","key","this","__key","__isSupport","__data","__listeners","Map","__eventQueue","__isUpdating","encryptionKey","useEncryption","__loadData","getInstance","instance","setKey","trim","Error","getKey","support","enableEncryption","enable","__generateEncryptionKey","log","set","value","ttl","success","Object","keys","forEach","k","v","oldValue","dataItem","timestamp","Date","now","__updateData","__createDynamicProperty","emit","error","get","defaultValue","__isExpired","remove","length","__removeDynamicProperty","clear","oldData","getAll","__cleanExpiredData","result","entries","has","getAllKeys","size","isEmpty","getInfo","expiredRemoved","isSupport","events","getEvents","totalListeners","Array","from","values","reduce","sum","listeners","isUpdating","hasEncryptionKey","debug","isExpired","remaining","Math","max","getTTLInfo","hasTTL","expiryTime","cleanExpired","JSON","stringify","import","jsonString","data","parse","newData","backup","restore","getStorageUsage","localStorage","getItem","Blob","isStorageFull","testKey","testValue","repeat","setItem","removeItem","on","event","callback","push","off","index","indexOf","splice","removeAllListeners","delete","getListenerCount","array","Uint8Array","crypto","getRandomValues","byte","toString","padStart","join","__encrypt","encrypted","i","charCode","charCodeAt","String","fromCharCode","btoa","console","__decrypt","decoded","atob","decrypted","removed","keysToRemove","decryptedData","jsonData","encryptedData","privateProperties","includes","defineProperty","configurable","filter","config","level","enabled","remote","setConfig","logs","getConfig","consoleLog","method","args","apply","warn","info","TemplateDetectorService","rootElement","document","body","cachedComments","setRootElement","element","getAllComments","useCache","comments","walker","createTreeWalker","NodeFilter","SHOW_COMMENT","node","nextNode","parseComment","commentNode","text","nodeValue","openMatch","match","fullName","attributes","attrMatch","attr","split","replace","type","closeMatch","getNodesBetween","startNode","endNode","parentNode","nodes","current","nextSibling","patternToRegex","pattern","regexStr","RegExp","matchPattern","test","find","options","parsed","map","c","p","pairs","stack","foundIndex","j","openTag","nodesBetween","closeTag","parent","findOne","filterFn","count","getUniqueNames","Set","display","pairsOrPattern","showAttributes","showParent","showNodes","maxNodePreview","patternInfo","pair","tagName","toLowerCase","className","slice","nodeType","Node","ELEMENT_NODE","TEXT_NODE","substring","clearCache","HttpService","baseUrl","timeout","defaultHeaders","setBaseUrl","url","setTimeout","setDefaultHeaders","headers","setHeader","name","request","fullUrl","startsWith","toUpperCase","controller","AbortController","timeoutId","abort","response","fetch","signal","clearTimeout","responseData","json","catch","status","ok","statusCode","post","put","patch"],"sourceRoot":""}